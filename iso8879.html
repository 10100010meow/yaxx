<!--
   HP1 is EM
   HP2 is STRONG
-->
<!ENTITY tab            "&#9;">
<!ENTITY vbar     SDATA "font=symbol charset=fontspecific code=189">
<!ENTITY tilde    CDATA "~">
<!ENTITY asterisk CDATA "*">
<!ENTITY mdash    SDATA "font=symbol charset=fontspecific code=190">
<!ENTITY copyr          "&#169;">
<!ENTITY lbrk     CDATA "[">
<!ENTITY rbrk     CDATA "]">
<!ENTITY odq            "&#147;">
<!ENTITY eodq           "&#148;">
<!ENTITY cdq            "&#148;">
<!ENTITY amp      CDATA "&">
<!ENTITY gt       CDATA ">">
<!ENTITY lt       CDATA "<">
<!ENTITY xclm     CDATA "!">
<!ENTITY caret          "&#172;">
<!ELEMENT break - O EMPTY>
<!ELEMENT nline - O EMPTY>
<USERDOC>
<PROLOG>
<TITLE>
<TOPIC>Information Processing -- Text and Office Systems --
Standard Generalized Markup Language (SGML)</TOPIC></TITLE>
<DOCNUM>ISO 8879:1986/A1:1988(E)</DOCNUM></PROLOG>
<FRONTM>
<TIPAGE>
<NOTICES>
<P>
<STRONG>Foreword</STRONG></P>
<P>ISO (the International Organization for Standardization) is a
worldwide federation of national standards bodies (ISO member bodies).
The work of preparing International Standards is normally carried out
through ISO technical committees.
Each member body interested in a subject for which a technical committee
has been established has the right to be represented on that committee.
International organizations, governmental and non-governmental, in
liaison with ISO, also take part in the work.</P>
<P>Draft International Standards adopted by the technical committees are
circulated to the member bodies for approval before their acceptance as
International Standards by the ISO Council.
They are approved in accordance with ISO procedures requiring at least
75 % approval by the member bodies voting.</P>
<P>International Standard ISO 8879 was prepared by Technical Committee
ISO/TC 97,
<EM>Information processing systems</EM>.</P>
<P>Users should note that all International Standards undergo revision
from time to time and that any reference made herein to any other
International Standard implies its latest edition, unless otherwise
stated.</P></NOTICES>
<VNOTICE>
<LOSTDATA></LOSTDATA>
<COPRNOTE>© International Organization for Standardization, 1986</COPRNOTE></VNOTICE>
<PREFACE TOPICID="INTRO">
<SPECHD>Introduction</SPECHD>
<LOSTDATA></LOSTDATA>
<P>This International Standard specifies a language for document representation
referred to as the
<Q>Standard Generalized Markup Language</Q> (SGML).
SGML can be used for publishing in its broadest definition,
ranging from single medium conventional publishing
to multi-media data base publishing.
SGML can also be used in office document processing
when the benefits of human readability
and interchange with publishing systems
are required.</P>
<H2>Background</H2>
<LOSTDATA></LOSTDATA>
<P>A document can be viewed in the abstract
as a structure of various types of element.
An author organizes a book into chapters
that contain paragraphs, for example,
and figures that contain figure captions.
An editor organizes a magazine into articles
that contain paragraphs that contain words, and so on.</P>
<P>Processors treat these elements in different ways.
A formatting program might print headings in prominent type face,
leave space between paragraphs,
and otherwise visually convey the structure and other attributes to the reader.
An information retrieval system would perhaps assign extra significance
to words in a heading when creating a dictionary.</P>
<P>Although this connection between a document's attributes
and its processing now seems obvious,
it tended to be obscured by early text processing methods.
In the days before automated typesetting,
an editor would
<Q>mark up</Q> a manuscript
with the specific processing instructions
that would create the desired format when executed by a compositor.
Any connection between the instructions and the document's structure
was purely in the editor's head.</P>
<P>Early computerized systems continued this approach
by adding the process-specific
<Q>markup</Q>
to the machine readable document file.
The markup still consisted of specific processing instructions,
but now they were in the language of a formatting program,
rather than a human compositor.
The file could not easily be used for a different purpose,
or on a different computer system,
without changing all the markup.</P>
<P>As users became more sophisticated,
and as text processors became more powerful,
approaches were developped that alleviated this problem.

<Q>Macro calls</Q> (or
<Q>format calls</Q>) were used
to identify points in the document where processing was to occur.
The actual processing instructions were kept outside of the document,
in
<Q>procedures</Q>
(or
<Q>macro definitions</Q> or
<Q>stored formats</Q>),
where they could more easily be changed.</P>
<P>While the macro calls could be placed anywhere in a document,
users began to recognize
that most were placed at the start or end of document elements.
It was natural, therefore, to choose names for such macros
that were
<Q>generic identifiers</Q> of the element types,
rather than names that suggested particular processing
(for example,
<Q>heading</Q> rather than
<Q>format-17</Q>),
and so the practice of
<Q>generic coding</Q>
(or
<Q>generalized tagging</Q>) began.</P>
<P>Generic coding was a major step towards
making automated text processing systems
reflect the natural relationship between document attributes and processing.
The advent of
<Q>generalized markup languages</Q> in the early 1970's
carried this trend further
by providing a formal language base for generic coding.
A generalized markup language observes two main principles:

<OL>
<LI>Descriptive markup predominates
and is distinguished from processing instructions.

<P>Descriptive markup includes both generic identifiers and other attributes
of document elements that motivate processing instructions.
The processing instructions, which can be in any language,
are normally collected outside of the document in procedures.</P>
<P>As the source file is scanned for markup
and the various elements are recognized,
the processing system executes the procedures associated
with each element and attribute for that process.
For other processes, different procedures can be associated
with the same elements and attributes
without changing the document markup.</P>
<P>When a processing instruction must be entered directly in a document,
it is delimited differently from descriptive markup
so that it can easily be located and changed for different processes.</P></LI>
<LI>Markup is formally defined for each type of document.

<P>A generalized markup language formalizes document markup
by incorporating
<Q>document type definitions</Q>.
Type definitions include a specification (like a formal grammar)
of which elements and attributes can occur in a document
and in what order.
With this information, it is possible to determine
whether the markup for an individual document is correct
(that is, complies with the type definition)
and also to supply markup that is missing,
because it can be inferred unambiguously from other markup that is present.</P></LI></OL></P>
<NT>A more detailled introduction to the concepts of generic coding
and the Standard Generalized Markup Language can be found in annex A.</NT>
<H2>Objectives</H2>
<LOSTDATA></LOSTDATA>
<P>The Standard Generalized Markup Language standardizes the application
of the generic coding and generalized markup concepts.
It provides a coherent and unambiguous syntax
for describing whatever a user chooses to identify within a document.
The language includes:

<UL>
<LI>An
<Q>abstract syntax</Q> for descriptive markup of document elements.</LI>
<LI>A
<Q>reference concrete syntax</Q> that binds the abstract syntax
to particular delimiter characters and quantities.
Users can define alternative concrete syntaxes to meet their requirements.</LI>
<LI>Markup declarations that allow the user to define a specific vocabulary
of generic identifiers and attributes for different document types.</LI>
<LI>Provisions for arbitrary data content.
In generalized markup,

<TOTO>Testing again</TOTO>

<Q>data</Q> is anything that is not defined by the markup language.
This can include specialized
<Q>data content notations</Q>
that require interpretation different from general text:
formulas, images, non-Latin alphabets,
previously formatted text, or graphics.</LI>
<LI>Entity references:
a non-system-specific technique for referring to content
located outside the mainstream of the document,
such as separetely-written chapters, pi characters, photographs, etc.</LI>
<LI>Special delimiters for processing instructions
to distinguish them from descriptive markup.
Processing instructions can be entered when needed
for situations that cannot be handled by the procedures,
but they can easily be found and modified later
when a document is sent to a different processing system.</LI></UL></P>
<P>For a generalized markup language to be an acceptable standard, however,
requires more than just providing the required functional capabilities.
The language must have metalinguistic properties,
in order to satisfy the constraints imposed
by the need to use it in a multiplicity of environments.
The major constraints,
and the means by which the Standard Generalized Markup Language
addresses them,
can be summarized as follows:

<OL>
<LI>Documents
<Q>marked up</Q> with the language must be processable
by a wide range of text processing and word processing systems.

<P>The full form of the language, with all optional features, offers
generality and flexibility that can be exploited by sophisticated systems;
less powerful systems need not support the features.
To facilitate interchange between dissimilar systems,
an
<Q>SGML declaration</Q> describes any markup features
or concrete syntax variations used in a document.</P></LI>
<LI>The millions of existing text entry devices must be supported.

<P>SGML documents, with the reference concrete syntax,
can easily be keyboarded and understood by humans,
without machine assistance.
As a result:

<UL SPREAD="COMPACT">
<LI>Use of SGML need not await the development and acceptance
of a new generation of hardware
-- just software to process the documents on existing machines.</LI>
<LI>Migration to such a new generation (when it comes) will be easier,
as users will already be familiar with SGML.</LI></UL></P></LI>
<LI>There must be no character set dependency,
as documents may be keyed on a variety of devices.

<P>The language has no dependency on a particular character set.
Any character set that has bit combinations for
letters, numerals, space, and delimiters is acceptable.</P></LI>
<LI>There must be no processing, system, or device dependencies.

<P>Generalized markup is predominantly descriptive
and therefore inherently free of such dependencies.
The occasional processing instruction is specially delimited
so it can be found and converted for interchange,
or when a different process renders the instruction irrelevant.</P>
<P>References to external parts of a document are indirect.
The mapping to real system storage
are made in
<Q>external entity declarations</Q>
that occur at the start of the document,
where they can easily be modified for interchange.</P>
<P>The concrete syntax can be changed with the SGML declaration
to accommodate any reserved system characters.</P></LI>
<LI>There must be no national language bias.

<P>The characters used for names can be augmented
by any special national characters.
Generic identifiers, attribute names,
and other names used in descriptive markup
are defined by the user in element and entity declarations.</P>
<P>The declaration names and keywords used in markup declarations
can also be changed.</P>
<P>Multiple character repertoires, as used in multi-lingual documents,
are supported.</P></LI>
<LI>The language must accommodate familiar
typewriter and word processor conventions.

<P>The
<Q>short reference</Q> and
<Q>data tag</Q> capabilities
support typewriter text entry conventions.
Normal text containing paragraphs and quotations is interpretable as SGML
although it is keyable with no visible markup.</P></LI>
<LI>The language must not depend on a particular data stream
or physical file organization.

<P>The markup language has a virtual storage model
in which documents consist of one or more storage entities,
each of which is a sequence of characters.
All real file access is handled by the processing system,
which can decide
whether the character sequence should be viewed as continuous,
or whether it should reflect physical record boundaries.</P></LI>
<LI>
<Q>Marked up</Q> text must coexist with other data.

<P>A processing system can allow text that conforms to this International Standard
to occur in a data stream with other material,
as long as the system can locate the start and end of the conforming text.</P>
<P>Similarly, a system can allow data content not defined by SGML
to occur logically within a conforming document.
The occurrence of such data is indicated by markup declarations
to facilitate interchange.</P></LI>
<LI>The markup must be usable by both humans and programs.

<P>The Standard Generalized Markup Language is intended as a suitable interface
for keyboarding and interchange without preprocessors.
It allows
extensive tailoring to accommodate user preferences in text entry conventions
and the requirements of a variety of keyboards and displays.</P>
<P>However, it is recognized that many implementers will take advantage
of the language's information capture capabilities
to provide intelligent editing or to create SGML documents
from a word-processing front-end environment.
SGML accommodates such uses by providing the following capabilities:

<UL SPREAD="COMPACT">
<LI>Element content can be stored separately from the markup.</LI>
<LI>Control characters can be used as delimiters.</LI>
<LI>Mixed mode of data representation are permitted in a document.</LI>
<LI>Multiple concurrent logical and layout structures are supported.</LI></UL></P></LI></OL></P>
<H2>Organization</H2>
<LOSTDATA></LOSTDATA>
<P>The organization of this International Standard is as follows:

<OL>
<LI>The physical organization of an SGML document as an entity structure
is specified in clause 6.</LI>
<LI>The logical organization of an SGML document as an element structure,
and its representation with descriptive markup,
is specified in clause 7.</LI>
<LI>Processing instructions are discussed in clause 8.</LI>
<LI>Common markup constructs, such as characters, entity references,
and processing instructions, are covered in clause 9.</LI>
<LI>Markup declarations with general applicability
(comment, entity, and marked section)
are specified in clause 10.</LI>
<LI>Markup declarations that are used primarily to specify
document type definitions
(document type, element, notation,
short reference mapping, and short reference use)
are defined in clause 11.</LI>
<LI>Markup declarations that are used primarily to specify
link process definitions
(link type, link attribute, link set, and link set use)
are defined in clause 12.</LI>
<LI>The SGML declaration, which specifies the document character set,
capacity set, concrete syntax, and features,
is defined in clause 13.</LI>
<LI>The reference concrete syntax
is defined in clause 14.</LI>
<LI>Conformance of documents, applications, and systems
is defined in clause 15.</LI></OL></P>
<P>There are also a number of annexes containing additional information:
they are not integral part of the body of this International Standard.</P>
<NT>This International Standard is a formal specification of a computer language,
which may prove difficult reading
for those whose expertise is in the production of documents,
rather than compilers.
Annexes A, B, and C discuss the main concepts in an informal tutorial style
that should be more accessible to most readers.
However, the reader should be aware that
those annexes do not cover all SGML constructs,
nor all details of those covered,
and subtle distinctions are frequently ignored
in the interest of presenting a clear overview.</NT></PREFACE></FRONTM>
<BODY>
<H1>Scope</H1>
<LOSTDATA></LOSTDATA>
<P>This International Standard:

<OL>
<LI>Specifies an abstract syntax known as
the Standard Generalized Markup Language (SGML).
The language expresses the description of a document's structure
and other attributes,
as well as other information that makes the markup interpretable.</LI>
<LI>Specifies a reference concrete syntax
that binds the abstract syntax to specific characters and numeric values,
and criteria for defining variant concrete syntaxes.</LI>
<LI>Defines conforming documents in terms of
their use of components of the language.</LI>
<LI>Defines conforming systems in terms of
their ability to process conforming documents
and to recognize markup errors in them.</LI>
<LI>Specifies how data not defined by this International Standard
(such as images, graphics, or formatted text)
can be included in a conforming document.</LI></OL></P>
<NT>This International Language does not:

<OL>
<LI>Identify or specify
<Q>standard</Q> document types,
document architectures, or text structures.</LI>
<LI>Specify the implementation, architecture, or markup error handling
of conforming systems.</LI>
<LI>Specify how conforming documents are to be created.</LI>
<LI>Specify the data stream, message handling system, file structure,
or other physical representation in which
conforming documents are stored or interchanged,
or any character set or coding scheme into or from which
conforming documents might be translated for such purposes.</LI>
<LI>Specify the data content representation or
notation for images, graphics, formatted text, etc.,
that are included in a conforming document.</LI></OL></NT>
<H1>Field of Application</H1>
<LOSTDATA></LOSTDATA>
<P>The Standard Generalized Markup Language can be used for documents
that are processed by any text processing or word processing system.
It is particulary applicable to:

<OL>
<LI>Documents that are interchanged among systems
with differing text processing languages.</LI>
<LI>Documents that are processed in more than one way,
even when the procedures use the same text processing language.</LI></OL></P>
<P>Documents that exist solely in final
<REV REFID="AMEND1">imaged</REV>
form
are not within the field of application of this International Standard.</P>
<H1>References</H1>
<LOSTDATA>
<FN ID="STGDF">At present at the stage of draft.</FN></LOSTDATA>
<P>ISO 639,

<CIT>Codes for the representation of names of languages.</CIT>

<FNREF REFID="STGDF"></P>
<P>ISO 646,

<CIT>Information processing --
<REV REFID="AMEND1">ISO</REV>
7-bit coded character set for information exchange.</CIT></P>
<P>ISO 9069,

<CIT>Information processing
-- SGML support facilities
-- SGML Document Interchange Format (SDIF).</CIT>

<FNREF REFID="STGDF"></P>
<P>ISO 9070,

<CIT>Information processing
-- SGML support facilities
-- Registration procedures for public text.</CIT>

<FNREF REFID="STGDF"></P>
<P>The following references are used in conjunction with illustrative materials:</P>
<P>ISO 2022,

<CIT>Information processing
-- ISO 7-bit and 8-bit coded character sets
-- Code extension techniques.</CIT></P>
<P>ISO 3166,

<CIT>Codes for the representation of names and countries.</CIT></P>
<P>ISO 4873,

<CIT>Information processing
-- ISO 8-bit code for information interchange
-- Structure and rules for implementation.</CIT></P>
<P>ISO 6937,

<CIT>Information processing
-- Coded character sets for text identification.</CIT></P>
<P>ISO 8632/2,

<CIT>Information processing systems
-- Computer graphics
-- Metafile for the storage and transfer
of picture description information
-- Part 2: Character encoding.</CIT>

<FNREF REFID="STGDF"></P>
<P>ISO 8632/4,

<CIT>Information processing systems
-- Computer graphics
-- Metafile for the storage and transfer
of picture description information
-- Part 4: Clear text encoding.</CIT>

<FNREF REFID="STGDF"></P>
<H1>Definitions</H1>
<LOSTDATA></LOSTDATA>
<NT>The typographic conventions described in 5.1 are employed in this clause.</NT>
<DL TSIZE="0">
<DT>4.1 abstract syntax (of SGML):</DT>
<DD>Rules that define how markup is added to the data of a document,
without regard to the specific characters used to represent the markup.</DD>
<DT>4.2 active document type (declaration):</DT>
<DD>
<REV REFID="AMEND1">A document type that the system has identified to be active.

<NT>An SGML entity is parsed with respect to its active document type, if any,
or if not, with respect to its base document type and any active link types.</NT></REV></DD>
<DT>4.3 active link type (declaration):</DT>
<DD>
<REV REFID="AMEND1">A link process that the system has identified as being active.</REV></DD>
<DT>4.4 ambiguous content model:</DT>
<DD>A
<HPV>content model</HPV> for which an element or character string
occurring in the document instance can satisfy more than
one
<HPV>primitive content token</HPV> without look-ahead.

<NT>Ambiguous content model are prohibited in SGML.</NT></DD>
<DT>4.5 application:</DT>
<DD>Text processing application.</DD>
<DT>4.6 application convention:</DT>
<DD>Application-specific rule governing the text in document areas
that SGML leaves to user choice.

<NT>There are two kinds: content conventions and markup conventions.</NT></DD>
<DT>4.7 application-specific information:</DT>
<DD>A parameter of the
<HPV>SGML declaration</HPV> that specifies information
required by an application and/or its architecture.

<NT>For example, the information could identify
an architecture and/or an application,
or otherwhise enable a system to determine whether it can process the document.</NT></DD>
<DT>4.8 associated element type:</DT>
<DD>An element type associated with the subject of a markup declaration
by its
<HPV>associated element type</HPV> parameter.
<REV REFID="AMEND1">
<DT>4.8.1 associated notation (name):</DT>
<DD>A notation name associated with the subject of a markup declaration
by its
<HPV>associated notation name</HPV> parameter.</DD></REV></DD>
<DT>4.9 attribute (of an element):</DT>
<DD>A characteristic quality, other than type or content.</DD>
<DT>4.10 attribute definition:</DT>
<DD>A member of an attribute definition list;
it defines an attribute name, allowed values, and default value.</DD>
<DT>4.11 attribute definition list:</DT>
<DD>A set of one or more attribute definitions defined by the

<HPV>attribute definition list</HPV> parameter
of an attribute definition list declaration.</DD>
<DT>4.12 attribute definition list (declaration):</DT>
<DD>A markup declaration that associates an attribute definition list
with one or more element types.</DD>
<DT>4.13 attribute list:</DT>
<DD>Attribute specification list.</DD>
<DT>4.14 attribute list declaration:</DT>
<DD>Attribute definition list declaration.</DD>
<DT>4.15 attribute specification:</DT>
<DD>A member of an attribute specification list;
it specifies the value of a single attribute.</DD>
<DT>4.16 attribute (specification) list:</DT>
<DD>Markup that is a set of one or more attribute specifications.

<NT>Attribute specification lists occur in start-tag and link sets.</NT></DD>
<DT>4.17 attribute value literal:</DT>
<DD>A delimited character string that is interpreted as an

<HPV>attribute value</HPV> by replacing references
and ignoring or translating function characters.</DD>
<DT>4.18 available public text:</DT>
<DD>Public text that is available to the general public,
though its owner may require
payment of a fee or performance of other conditions.</DD>
<DT>4.19 B sequence:</DT>
<DD>An uninterrupted sequence of upper-case letter
<Q>B</Q> characters;
in a string assigned as a short reference, it denotes a blank sequence
whose minimum length is the length of the B sequence.</DD>
<DT>4.20 base document element:</DT>
<DD>A document element whose document type is the base document type.</DD>
<DT>4.21 base document type:</DT>
<DD>The document type specified by the first document type declaration in a prolog.</DD>
<DT>4.22 basic SGML document:</DT>
<DD>A conforming SGML document
that uses the reference concrete syntax and capacity set
and the SHORTTAG and OMITTAG markup minimization features.

<NT>It also uses the SHORTREF feature
by virtue of using the reference concrete syntax.</NT></DD>
<DT>4.23 bit:</DT>
<DD>Binary digit; that is, either zero or one.</DD>
<DT>4.24 bit combination:</DT>
<DD>An ordered collection of bits, interpretable as a binary number.</DD>
<DT>4.25 blank sequence:</DT>
<DD>An uninterrupted sequence of
<HPT>SPACE</HPT> and/or
<HPT>SEPCHAR</HPT>
characters.</DD>
<DT>4.26 capacity:</DT>
<DD>A named limit on some aspect of the size and complexity of a document,
expressed as a number of points that can be accumulated
for a kind of object or for all objects.

<NT>The set of capacities is defined by the abstract syntax,
but values are assigned to them by individual documents and SGML systems.</NT></DD>
<DT>4.27 capacity set:</DT>
<DD>A set of assignments of numeric values to capacity names.

<NT>In an SGML declaration,
the capacity set identifies the maximum capacity requirements of the document
(its actual requirements may be lower).
A capacity set can also be defined by an application,
to limit the capacity requirements of documents
that implementations of the application must process,
or by a system, to specify the capacity requirements
that it is capable of meeting.</NT></DD>
<DT>4.28 CDATA:</DT>
<DD>Character data.</DD>
<DT>4.29 CDATA entity:</DT>
<DD>Character data entity.</DD>
<DT>4.30 chain of (link) processes:</DT>
<DD>Processes, performed sequentially, that form a chain in which
the source of the first process is an instance of the base document type,
and the result of each process but the last is the source for the next.
Any portion of the chain can be iterated.

<NT>For example, a complex page makeup application could include
three document types
-- logical, galley, and page --
and two link processes
-- justification and castoff.
The justification process would create an instance of a galley
from an instance of a logical document,
and the castoff process would in turn create pages from the galleys.
The two processes could be iterated,
as decisions made during castoff could require
re-justification of the galleys at different sizes.</NT></DD>
<DT>4.31 character:</DT>
<DD>An atom of information with an individual meaning,
defined by a character repertoire.

<NOTEL>
<LI>There are two kinds: graphic character and control character.</LI>
<LI>A character can occur in a context in which it has a meaning,
defined by markup or a data content notation,
that supercedes or supplements its meaning in the character repertoire.</LI></NOTEL></DD>
<DT>4.32 (character) class:</DT>
<DD>A set of characters that have a common purpose in the abstract syntax,
such as non-SGML characters or separator characters.

<NT>Specific characters are assigned to character classes in four different ways:

<OL SPREAD="COMPACT">
<LI>explicitly, by the abstract syntax (
<HPC>Special</HPC>,

<HPC>Digit</HPC>,
<HPC>LC Letter</HPC>, and
<HPC>UC Letter</HPC>);</LI>
<LI>explicitly, by the concrete syntax (
<HPT>LCNMSTRT</HPT>,

<HPT>FUNCHAR</HPT>,
<HPT>SEPCHAR</HPT>, etc.);</LI>
<LI>implicitly, as the result of explicit assignments made to
delimiter roles or other character classes
(
<HPT>DELMCHAR</HPT>, and
<HPT>DATACHAR</HPT>); or</LI>
<LI>explicitly, by the document character set (
<HPT>NONSGML</HPT>).</LI></OL></NT></DD>
<DT>4.33 character data:</DT>
<DD>Zero or more characters that occur in context in which no markup is recognized,
other than the delimiters that end the
<HPV>character data</HPV>.
Such characters are classified as data characters
because they were declared to be so.</DD>
<DT>4.34 character data entity:</DT>
<DD>An entity whose text is treated as
<HPV>character data</HPV> when referenced
and is not dependent on a specific system, device, or application process.</DD>
<DT>4.35 character entity set:</DT>
<DD>A public entity set consisting of general entities that are graphic characters.

<NOTEL>
<LI>Character entities are used for characters
that have no coded representation in the document character set,
or that cannot be keyboarded conveniently,
or to achieve device independence for characters
whose bit combinations do not cause proper display on all output devices.</LI>
<LI>There are two kinds of character entity sets: definitional and display.</LI></NOTEL></DD>
<DT>4.36 character number:</DT>
<DD>A
<HPV>number</HPV> that represents the base-10 integer
equivalent of the coded representation of a character,
obtained by treating the sequence of bit combinations
as a single base-2 integer.</DD>
<DT>4.37 character reference:</DT>
<DD>A reference that is replaced by a single character.

<NT>There are two kinds: named character reference and numeric character reference.</NT></DD>
<DT>4.38 character repertoire:</DT>
<DD>A set of characters that are used together.
Meanings are defined for each character,
and can also be defined for control sequences of multiple characters.

<NT>When a character occurs in a control sequence,
the meaning of the sequence
supercedes the meanings of the individual characters.</NT></DD>
<DT>4.39 character set:</DT>
<DD>A mapping of a character repertoire onto a code set
such that each character is associated with its coded representation.</DD>
<DT>4.40 (character) string:</DT>
<DD>A sequence of characters.</DD>
<DT>4.41 class:</DT>
<DD>Character class.</DD>
<DT>4.42 code extension:</DT>
<DD>The use of a single coded representation for more than one character,
without changing the document character set.

<NT>When multiple national languages occur in a document,
graphic repertoire code extension may be useful.</NT></DD>
<DT>4.43 code set:</DT>
<DD>A set of bit combinations of equal size,
ordered by their numeric values, which must be consecutive.

<NT>For example, a code set whose bit combinations have 8 bits
(an
<Q>8-bit code</Q>) could consist as many as 256 bit combinations,
ranging in value from 00000000 through 11111111
(0 through 255 in the decimal number base),
or it could consist of any contiguous subset of those bit combinations.</NT></DD>
<DT>4.44 code set position:</DT>
<DD>The numeric value of a bit combination in a code set.</DD>
<DT>4.45 coded representation:</DT>
<DD>The representation of a character
as a sequence of one or more bit combinations of equal size.</DD>
<DT>4.46 comment:</DT>
<DD>A portion of a markup declaration that contains explanations or remarks
intended to aid persons working with the document.</DD>
<DT>4.47 comment declaration:</DT>
<DD>A markup declaration that contains only comments.</DD>
<DT>4.48 concrete syntax (of SGML):</DT>
<DD>A binding of the abstract syntax to particular delimiter characters,
quantities, markup declaration names, etc.</DD>
<DT>4.49 concrete syntax parameter:</DT>
<DD>A parameter of the SGML declaration that identifies the concrete syntax
used in document elements and (usually) prologs.

<NT>The parameter consists of parameters that identify
the syntax-reference character set, function characters,
shunned characters, naming rules, delimiter use, reserved name use,
and quantitative characteristics.</NT></DD>
<DT>4.50 conforming SGML application:</DT>
<DD>An SGML application that requires documents to be conforming SGML documents,
and whose documentation meets the requirements of this International Standard.</DD>
<DT>4.51 conforming SGML document:</DT>
<DD>An SGML document that complies
with all provisions of this International Standard.</DD>
<DT>4.52 containing element:</DT>
<DD>An element within which a subelement occurs.</DD>
<DT>4.53 content:</DT>
<DD>Characters that occur between start-tag and end-tag of an element
in a document instance.
They can be interpreted as data, proper subelements, included subelements,
other markup, or a mixture of them.

<NT>If an element has an explicit content reference,
or its declared content is "EMPTY",
the content is empty.
In such case, the application itself may generate data
and process it as though it were content data.</NT></DD>
<DT>4.54 content convention:</DT>
<DD>An application convention governing data content,
such as restriction on length, allowable characters,
or use of upper-case and lower-case letters.

<NT>A content convention is essentially an informal data content notation,
usually restricted to a single element type.</NT></DD>
<DT>4.55 (content) model:</DT>
<DD>Parameter of an element declaration that specifies
the
<HPV>model group</HPV> and
<HPV>exceptions</HPV>
that define the allowed
<HPV>content</HPV> of the element.</DD>
<DT>4.56 content model nesting level:</DT>
<DD>The largest number of successive
<HPD>grpo</HPD> or
<HPD>dtgo</HPD>
delimiters that occur in a
<HPV>content model</HPV> without a corresponding

<HPD>grpc</HPD> or
<HPD>dtgc</HPD> delimiter.</DD>
<DT>4.57 content reference (attribute):</DT>
<DD>An impliable attribute whose value is referenced by the application
to generate content data.

<NT>When an element has an explicit content reference,
the element's
<HPV>content</HPV> in the document instance is empty.</NT></DD>
<DT>4.58 contextual sequence:</DT>
<DD>A sequence of one or more markup characters
that must follow a delimiter string within the same entity
in order for the string to be recognized as a delimiter.</DD>
<DT>4.59 contextually optional element:</DT>
<DD>An element

<OL SPREAD="COMPACT">
<LI>that can occur only because it is an inclusion;
or</LI>
<LI>whose
<HPV>content token</HPV> in the currently applicable model group
is a contextually optional token.</LI></OL></DD>
<DT>4.60 contextually optional token:</DT>
<DD>A
<HPV>content token</HPV> that

<OL SPREAD="COMPACT">
<LI>is an inherently optional token;
or</LI>
<LI>has a
<HPD>plus</HPD> occurrence indicator and has been satisfied;
or</LI>
<LI>is in a model group that is itself a contextually optional token,
no tokens of which have been satisfied.</LI></OL></DD>
<DT>4.61 contextually required element:</DT>
<DD>An element that is not a contextually optional element and

<OL SPREAD="COMPACT">
<LI>whose
<HPV>generic identifier</HPV> is the
<HPV>document type name</HPV>;
or</LI>
<LI>whose currently applicable model token is a contextually required token.</LI></OL>

<NT>An element could be neither contextually required nor contextually optional;
for example, an element whose currently applicable model token
is in an
<HPD>or</HPD> group that has no inherently optional tokens.</NT></DD>
<DT>4.62 contextually required token:</DT>
<DD>A
<HPV>content token</HPV> that

<OL SPREAD="COMPACT">
<LI>is the only one in its model group;
or</LI>
<LI>is in a
<HPD>seq</HPD> group

<OL SPREAD="COMPACT">
<LI>that

<UL SPREAD="COMPACT">
<LI>is itself a contextually required token; or</LI>
<LI>contains a token which has been satisfied;</LI></UL></LI>
<LI>all preceding tokens of which

<UL SPREAD="COMPACT">
<LI>have been satisfied; or</LI>
<LI>are contextually optional.</LI></UL></LI></OL></LI></OL></DD>
<DT>4.63 control character:</DT>
<DD>A character
that controls the interpretation, presentation, or other processing
of the characters that follow it;
for example, a tab character.</DD>
<DT>4.64 control sequence:</DT>
<DD>A sequence of characters, beginning with a control character,
that controls the interpretation, presentation, or other processing
of the characters that follow it;
for example, an escape sequence.</DD>
<DT>4.65 core concrete syntax:</DT>
<DD>A variant of the reference concrete syntax
that has no short reference delimiters.</DD>
<DT>4.66 corresponding content (of a content token):</DT>
<DD>The element(s) and/or data in a document instance
that correspond to a
<HPV>content token</HPV>.</DD>
<DT>4.67 current attribute:</DT>
<DD>An attribute whose current (that is, most recently specified) value
<REV REFID="AMEND1">becomes its default value.</REV>

<NT>The start-tag cannot be omitted for the first occurrence of an element
with a current attribute.</NT></DD>
<DT>4.68 current element:</DT>
<DD>The open element whose
<HPV>start-tag</HPV> most recently occurred
(or was omitted through markup minimization)</DD>
<DT>4.69 current link set:</DT>
<DD>The link set associated with the current element
by a
<HPV>link set use declaration</HPV> in the element content
<REV REFID="AMEND1">or by a link process definition.</REV>
If the current element has no associated link set,
the previous current link set continues to be the current link set.</DD>
<DT>4.70 current map:</DT>
<DD>The short reference map associated with the current element
by a
<HPV>short reference use</HPV> declaration
in the element content or document type definition.
If the current element has no associated map,
the previous current map continues to be the current map.</DD>
<DT>4.71 current rank:</DT>
<DD>A number that is appended to a rank stem in a tag
to derive the generic identifier.
For a
<HPV>start-tag</HPV> it is the
<HPV>rank suffix</HPV>
of the most recent element with the identical
<HPV>rank stem</HPV>,
or a
<HPV>rank stem</HPV> in the same
<HPV>ranked group</HPV>.
For an
<HPV>end-tag</HPV> it is the
<HPV>rank suffix</HPV>
of the most recent open element with the identical
<HPV>rank stem</HPV>.</DD>
<DT>4.72 data:</DT>
<DD>The characters of a document that represent the inherent information content;
characters that are not recognized as markup.
<REV REFID="AMEND1">
<DT>4.72.1 data attribute:</DT>
<DD>An attribute of the data conforming to a particular data content notation.

<NT>In most cases, the value of the data attributes must be known
before the data can be interpreted in accordance with the notation.</NT></DD></REV></DD>
<DT>4.73 data character:</DT>
<DD>An
<HPV>SGML character</HPV>
that is interpreted as data in the context in which it occurs,
either because it was declared to be data,
or because it was not recognizable as markup.</DD>
<DT>4.74 data content:</DT>
<DD>The portion of an element's
<HPV>content</HPV>
that is data rather than markup or a subelement.</DD>
<DT>4.75 data content notation:</DT>
<DD>An application-specific interpretation of an element's data content,
<REV REFID="AMEND1">or of a data entity,</REV>
that usually extends or differs from the normal meaning of the
document character set.

<NT>It is specified
for an element's
<HPV>content</HPV> by a notation attribute,
<REV REFID="AMEND1">and for a data entity by the
<HPV>notation name</HPV> parameter</REV>
of the entity declaration.</NT>
<REV REFID="AMEND1">
<DT>4.75.1 data entity:</DT>
<DD>An entity that was declared to be data
and therefore is not parsed when referenced.

<NT>There are three kinds:
character data entity, specific character data entity and non-SGML data entity.</NT></DD></REV></DD>
<DT>4.76 data tag:</DT>
<DD>A string that conforms to the data tag pattern of an open element.
It serves both as the
<HPV>end-tag</HPV> of an open element
and as
<HPV>character data</HPV> in the element that contains it.</DD>
<DT>4.77 data tag group:</DT>
<DD>A model group token that associates a data tag pattern
with a target element type.

<NT>Within an instance of a target element,
the data content and that of any subelements
is scanned for a string that conforms to the pattern (a
<Q>data tag</Q>).</NT></DD>
<DT>4.78 data tag pattern:</DT>
<DD>A data tag group token that defines the strings that,
if they occurred in the proper context,
would constitute a data tag.</DD>
<DT>4.79 declaration:</DT>
<DD>Markup declaration.</DD>
<DT>4.80 declaration subset:</DT>
<DD>A delimited portion of a markup declaration
in which other declarations can occur.

<NT>Declaration subset occur only in
document type, link type, and marked section declarations.</NT></DD>
<DT>4.81 declared concrete syntax:</DT>
<DD>The concrete syntax described by the
<HPV>concrete syntax</HPV> parameter
of the
<HPV>SGML declaration</HPV>.</DD>
<DT>4.82 dedicated data characters:</DT>
<DD>Character class consisting of each
<HPV>SGML character</HPV>
that has no possible meaning as markup;
a member is never treated as anything but a
<HPV>data character</HPV>.</DD>
<DT>4.83 default entity:</DT>
<DD>The entity that is referenced by a general entity reference
with an undeclared name.</DD>
<DT>4.84 default value:</DT>
<DD>A portion of an attribute definition that specifies the attribute value
to be used if there is no
<HPV>attribute specification</HPV> for it.</DD>
<DT>4.85 definitional (character) entity set:</DT>
<DD>A character entity set whose purpose is
to define entity names for graphic characters,
but not actually to display them.
Its
<HPV>public identifier</HPV> does not include
a
<HPV>public text display version</HPV>.

<NT>During processing,
the system replaces a definitional entity set
with a corresponding display character entity set
for the appropriate output device.</NT></DD>
<DT>4.86 delimiter characters:</DT>
<DD>Character class that consists of each
<HPV>SGML character</HPV>,
other than a
<HPV>name character</HPV> or
<HPV>function character</HPV>,
that occurs in a string assigned to a delimiter role by the concrete syntax.</DD>
<DT>4.87 delimiter-in-context:</DT>
<DD>A character string that consists of a delimiter string
followed immediately in the same entity by a contextual sequence.</DD>
<DT>4.88 delimiter role:</DT>
<DD>A role defined by the abstract syntax,
and filled by a character string assigned by the concrete syntax,
that involves identifying parts of the markup and/or
distinguishing markup from data.</DD>
<DT>4.89 delimiter set:</DT>
<DD>A set of assignments of delimiter strings
to the abstract syntax delimiter roles.</DD>
<DT>4.90 delimiter set parameter:</DT>
<DD>A parameter of an SGML declaration
that identifies the delimiter set used in the declared concrete syntax.</DD>
<DT>4.91 delimiter (string):</DT>
<DD>A character string assigned to a delimiter role by the concrete syntax.</DD>
<DT>4.92 descriptive markup:</DT>
<DD>Markup that describes the structure and other attributes of a document
in a non-system specific manner,
independently of any processing that may be performed on it.
In particular, it uses tags to express the element structure.</DD>
<DT>4.93 device dependent version (of public text):</DT>
<DD>Public text
whose
<HPV>formal public identifier</HPV> differs
from that of another public text
only by the addition of a
<HPV>public text display version</HPV>,
which identifies the display devices supported or coding scheme used.</DD>
<DT>4.94 digits:</DT>
<DD>Character class
composed of the 10 Arabic numerals from
<Q>0</Q> through
<Q>9</Q>.</DD>
<DT>4.95 display (character) entity set:</DT>
<DD>An entity set with the same entity names
as a corresponding definitional character entity set,
but which causes the character to be displayed.
It is a device-dependent version of the corresponding definitional entity set.</DD>
<DT>4.96 document:</DT>
<DD>A collection of information that is processed as a unit.
A document is classified as being of a particular document type.

<NT>In this International Standard,
the term almost invariably means (without loss of accuracy) an SGML document.</NT></DD>
<DT>4.97 document architecture:</DT>
<DD>Rules for the formulation of text processing applications.

<NOTEL>
<LP>For example, a document architecture can define:</LP>
<LI>attribute semantics for use in a variety of element definitions;</LI>
<LI>element classes, based on which attributes the elements have;</LI>
<LI>structural rules for defining document types in term of element classes;</LI>
<LI>link processes, and how they are affected by the values of attributes;
and/or</LI>
<LI>information to accompany a document during interchange
(a
<Q>document profile</Q>).</LI></NOTEL></DD>
<DT>4.98 document character set:</DT>
<DD>The character set used for all markup in an SGML document,
and initially (at least) for data.

<NT>When a document is interchanged between systems,
its character set is translated to the receiving system character set.</NT></DD>
<DT>4.99 document element:</DT>
<DD>The element that is the outermost element of an instance of a document type;
that is, the element whose
<HPV>generic identifier</HPV>
is the
<HPV>document type name</HPV>.</DD>
<DT>4.100 document instance:</DT>
<DD>Instance of a document type.</DD>
<DT>4.101 document instance set:</DT>
<DD>The portion of an
<HPV>SGML document entity</HPV>
or
<HPV>SGML subdocument entity</HPV>
in the entity structure that contains one or more instances of document types.
It is coextensive with the base document element in the element structure.

<NT>When the concurrent instance feature is used,
multiple instances can exist in a document,
and data and markup can be shared among them.</NT></DD>
<DT>4.102 document type:</DT>
<DD>A class of documents having similar characteristics;
for example, journal, article, technical manual, or memo.</DD>
<DT>4.103 (document) type declaration:</DT>
<DD>A markup declaration that contains the formal specification
of a document type definition.</DD>
<DT>4.104 document type declaration subset:</DT>
<DD>The element, entity, and short reference sets
occurring within the declaration subset of a document type declaration.

<NT>The external entity referenced from the document type declaration
is considered part of the declaration subset.</NT></DD>
<DT>4.105 document (type) definition:</DT>
<DD>Rules, determined by an application,
that apply SGML to the markup of documents of a particular type.
A document type definition includes a formal specification,
expressed in a document type declaration,
of the element types, element relationships and attributes,
and references that can be represented by markup.
It thereby defines the vocabulary of the markup
for which SGML defines the syntax.

<NT>A document type definition can also include comments
that describe the semantics of elements and attributes,
and any application conventions.</NT></DD>
<DT>4.106 document type specification:</DT>
<DD>A portion of a tag or entity reference
that identifies the document type instances
within which the tag or entity reference will be processed.</DD>
<DT>4.107 ds (separator):</DT>
<DD>A declaration separator, occurring in declaration subsets.</DD>
<DT>4.108 DTD:</DT>
<DD>Document type definition.</DD>
<DT>4.109 effective status (of a marked section):</DT>
<DD>The highest priority status keyword
specified on a markup section declaration.</DD>
<DT>4.110 element:</DT>
<DD>A component of the hierarchical structure
defined by a document type definition;
it is identified in a document instance by descriptive markup,
usually a start-tag and end-tag.

<NT>An element is classified as being of a particular element type.</NT></DD>
<DT>4.111 element declaration:</DT>
<DD>A markup declaration that contains the formal specification
of the part of an element type definition
that deals with the content and markup minimization.</DD>
<DT>4.112 element set:</DT>
<DD>A set of element declarations that are used together.

<NT>An element set can be public text.</NT></DD>
<DT>4.113 element structure:</DT>
<DD>The organization of a documnet into hierarchies of elements,
which each hierarchy conforming to a different document type definition.</DD>
<DT>4.114 element type:</DT>
<DD>A class of elements having similar characteristics;
for example, paragraph, chapter, abstract, footnote, or bibliography.</DD>
<DT>4.115 element (type) definition:</DT>
<DD>Application-specific rules
that apply SGML to the markup of elements of a particular type.
An element type definition includes a formal specification,
expressed in element and attribute definition list declarations,
of the content, markup minimization, and attributes
allowed for a specified element type.

<NT>An element type definition is normally part of a document type definition.</NT></DD>
<DT>4.116 element type parameter:</DT>
<DD>A parameter of an element declaration
that identifies the type of the element to which the definition applies.

<NT>The specification can be direct,
in the form of an individual
<HPV>generic identifier</HPV>
or member of a
<HPV>name group</HPV>,
or indirect,
via a
<HPV>ranked element</HPV> or member of a
<HPV>ranked group</HPV>.</NT></DD>
<DT>4.117 empty link set:</DT>
<DD>A link set in which all result element types are implied,
and no attributes are specified.</DD>
<DT>4.118 empty map:</DT>
<DD>A short reference map in which all delimiters are mapped to nothing.

<NT>The empty map need not (and cannot) be declared explicitly,
but can be referenced by its reserved name,
which is
<Q>#EMPTY</Q> in the reference concrete syntax.</NT></DD>
<DT>4.119 end-tag:</DT>
<DD>Descriptive markup that identifies the end of an element.</DD>
<DT>4.120 entity:</DT>
<DD>A collection of characters that can be referenced as a unit.

<NOTEL>
<LI>Objects such as
book chapters written by different authors, pi characters, or photographs,
are often best managed by maintaining them as individual entities.</LI>
<LI>The physical organization of entities is system-specific,
and could take the form of files, members of a partitionned data set,
components of a data structure, or entries in a symbol table.</LI></NOTEL></DD>
<DT>4.121 entity declaration:</DT>
<DD>A markup declaration that assigns an SGML name to an entity
so that it can be referenced.</DD>
<DT>4.122 entity end (signal):</DT>
<DD>A signal from the system that an entity's replacement text has ended.</DD>
<DT>4.123 entity manager:</DT>
<DD>A program (or portion of a program, or combination of programs),
such as a file system or a symbol table,
that can maintain and provide access to multiple entities.</DD>
<DT>4.124 entity reference:</DT>
<DD>A reference that is replaced by an entity.

<NT>There are two kinds: named entity reference and short reference.</NT></DD>
<DT>4.125 entity set:</DT>
<DD>A set of entity declarations that are used together.

<NT>An entity set can be public text.</NT></DD>
<DT>4.126 entity structure:</DT>
<DD>The organization of a document into one or more separate entities.

<NT>The first entry is an
<HPV>SGML document entity</HPV>;
it contains entity references
that indicate where the other entities belong with respect to it.</NT></DD>
<DT>4.127 entity text:</DT>
<DD>The entity declaration parameter that specifies the replacement text,
either by including it in a parameter literal,
or by pointing to it with an external identifier.</DD>
<DT>4.128 equivalent reference string:</DT>
<DD>A character string,
consisting of an entity reference
and possibly an
<HPT>RE</HPT> and/or
<HPT>RS</HPT>,
that replaces a short reference
when a document is converted from a concrete syntax
that supports short references to one that does not.</DD>
<DT>4.129 escape sequence:</DT>
<DD>A controle sequence whose first character is escape (ESC).</DD>
<DT>4.130 exceptions:</DT>
<DD>A parameter of an element declaration
that modifies the effect of the element's
<HPV>content model</HPV>,
and the content models of elements occurring within it,
by permitting inclusions and prohibiting exclusions.</DD>
<DT>4.131 exclusions:</DT>
<DD>Elements that are not allowed
anywhere in the content of an element or its subelements
even though the applicable content model or inclusions
would permit them optionaly.</DD>
<DT>4.132 explicit content reference:</DT>
<DD>A content reference that was specified in an
<HPV>attribute specification</HPV>.</DD>
<DT>4.133 explicit link (process definition):</DT>
<DD>A link process definition in which
the result element types and their attributes
and multiple sets of link attribute values can be specified.</DD>
<DT>4.134 external entity:</DT>
<DD>An entity whose text is not incorporated directly in an entity declaration;
its system identifier and/or public identifier is specified instead.

<NT>A document type or link type declaration can include the identifier
of an external entity containing all or part of the declaration subset;
the external identity serves simultaneously as both
the entity declaration and the entity reference.</NT></DD>
<DT>4.135 external identifier:</DT>
<DD>A parameter that identifies an external entity or data content notation.

<NT>There are two kinds: system identifier and public identifier.</NT></DD>
<DT>4.136 fixed attributes:</DT>
<DD>An attribute whose specified value (if any)
must be identical to its default value.</DD>
<DT>4.137 formal public identifier:</DT>
<DD>A public identifier that is constructed according to rules
defined in this International Standard
so that its owner identifier and the components of its text identifier
can be distinguished.</DD>
<DT>4.138 formal public identifier error:</DT>
<DD>An error in the construction or use of a
<HPV>formal public identifier</HPV>,
other than an error that would prevent it
being a valid
<HPV>minimum literal</HPV>.

<NT>A valid identifier can occur only
if "FORMAL YES" is specified on the
<HPV>SGML declaration</HPV>.
A failure of a
<HPV>public identifier</HPV> to be a minimum literal, however,
is always an error.</NT></DD>
<DT>4.139 function character:</DT>
<DD>A markup character assigned by the concrete syntax,
that can perform some SGML function
in addition to potentially being recognized as markup.
If it is not recognized as markup in a context in which data is allowed
it is treated as data
(unless the language dictates special treatments,
as in the case of the
<HPT>RE</HPT> and
<HPT>RS</HPT> function characters).</DD>
<DT>4.140 function character identification parameter:</DT>
<DD>A parameter of an SGML declaration that identifies the character assigned to
the
<HPT>RE</HPT>,
<HPT>RS</HPT>, and
<HPT>SPACE</HPT> functions,
and allows additional functions to be defined.</DD>
<DT>4.141 G0 set:</DT>
<DD>In graphic repertoire code extension,
the virtual character set that represents
the document character set graphic characters
whose character numbers are below 128,
in their normal code set positions.</DD>
<DT>4.142 general delimiter (role):</DT>
<DD>A delimiter role other than a short reference.</DD>
<DT>4.143 general entity:</DT>
<DD>
<REV REFID="AMEND1">An entity that can be</REV>referenced from within the content of
an element or an attribute value literal.</DD>
<DT>4.144 general entity reference:</DT>
<DD>A named entity reference to a general entity.</DD>
<DT>4.145 generic identifier:</DT>
<DD>A name that identifies the element type of an element.</DD>
<DT>4.146 GI:</DT>
<DD>Generic identifier.</DD>
<DT>4.147 graphic character:</DT>
<DD>A character such as a letter, digit, or ponctuation,
that normally occupies a single position when text is displayed.</DD>
<DT>4.148 Graphic repertoire code extension:</DT>
<DD>Code extension in which multiple graphic character sets
are mapped onto positions of the document code set
by using shift functions to invoke virtual character sets.</DD>
<DT>4.149 group:</DT>
<DD>The portion of a parameter that is bounded by a balanced pair of

<HPD>grpo</HPD> and
<HPD>grpc</HPD> or
<HPD>dtgo</HPD> and
<HPD>dtgc</HPD>
delimiters.

<NT>There are five kinds: name group, name token group, model group,
data tag group and data tag template group.
A name, name token, or data tag template group cannot contain a group,
but a model group can contain a model group
and a data tag group can contain a data tag template group.</NT></DD>
<DT>4.150 ID:</DT>
<DD>Unique identifier.</DD>
<DT>4.151 ID reference list:</DT>
<DD>An attribute value that is a list of ID reference values.</DD>
<DT>4.152 ID reference value:</DT>
<DD>An attribute value that is a
<HPV>name</HPV> specified as
an
<HPV>id value</HPV> of an element in the same document instance.</DD>
<DT>4.153 ID value:</DT>
<DD>An attribute value that is a
<HPV>name</HPV>
that uniquely identifies the element;
that is, it cannot be the same as another
<HPV>id value</HPV>
in the same document instance.</DD>
<DT>4.154 impliable attribute:</DT>
<DD>An attribute for which there need not be an
<HPV>attribute specification</HPV>,
and whose value is defined by the application when it is not specified.</DD>
<DT>4.155 implicit link (process definition):</DT>
<DD>A link process definition in which
the result element types and their attributes
are all implied by the application,
but multiple sets of link attribute values can be specified.
<REV REFID="AMEND1">
<DT>4.156 included subelement:</DT>
<DD>A subelement that is not permitted by its containing elements' model,
but is permitted by an inclusion exception.</DD>
<DT>4.157 inclusions:</DT>
<DD>Elements that are allowed anywhere
in the content of an element or its subelements
even though the applicable model does not permit them.</DD>
<DT>4.158 inert function characters:</DT>
<DD>Character class consisting of function characters
whose additional SGML
<Q>function</Q> is to do nothing.</DD></REV></DD>
<DT>4.159 inherently optional token:</DT>
<DD>A model group token that:

<OL SPREAD="COMPACT">
<LI>has an
<HPD>opt</HPD> or
<HPD>rep</HPD> occurrence indicator;
or</LI>
<LI>is in an
<HPD>or</HPD> group one of whose tokens is inherently optional;
or</LI>
<LI>is an
<HPD>and</HPD> or
<HPD>seq</HPD> group,
all of whose tokens are inherently optional.</LI></OL>
<REV REFID="AMEND1">
<DT>4.159.1 initial link set:</DT>
<DD>The link set that is current at the start of the document instance.</DD></REV></DD>
<DT>4.160 instance (of a document type):</DT>
<DD>The data and markup for a hierarchy of elements
that conforms to a document type definition.</DD>
<DT>4.161 interpreted parameter literal:</DT>
<DD>The text of a
<HPV>parameter literal</HPV>, exclusive of the literal delimiters,
in which character and parameter entity references have been replaced.</DD>
<DT>4.162 ISO owner identifier:</DT>
<DD>An
<HPV>owner identifier</HPV>,
consisting of an ISO publication number or character set registration number,
that is used
when a
<HPV>public identifier</HPV> identifies, or is assigned by, an ISO publication,
or identifies an ISO registered character set.</DD>
<DT>4.163 ISO text description:</DT>
<DD>A
<HPV>public text description</HPV>,
consisting of the last element of an ISO publication title
(without part designation, if any),
that is used
when a
<HPV>public identifier</HPV> identifies an ISO publication.</DD>
<DT>4.164 keyword:</DT>
<DD>A parameter that is a reserved name defined by the concrete syntax,
as opposed to arbitrary text.

<NT>In parameters
where either a keyword or a name defined by an application could be specified,
the keyword is always preceded by the reserved name indicator.
An application is therefore able to define names
without regard to whether those names are also used by the concrete syntax.</NT></DD>
<DT>4.165 link attributes:</DT>
<DD>An attribute of a source element type that is meaningful
only in the context of a particular process
that is performed on the source document instance.</DD>
<DT>4.166 link process:</DT>
<DD>A process that creates a new instance of some document type (the result)
from an existing instance of the same or another document type (the source).
Processes can be chained, so that the result of one is the source of the next.

<NT>Example of link processes include editing,
in which the source and result document type document types
are usually the same,
and formatting,
in which they are usually different.</NT></DD>
<DT>4.167 link process definition:</DT>
<DD>Application-specific rules that apply SGML to describe a link process.
A link process definition includes a formal specification,
expressed in a
<HPV>link type declaration</HPV>,
of the link between elements of the source and result,
including the definitions of source attributes applicable to the link process
(
<Q>link attributes</Q>).

<NOTEL>
<LI>A link process definition can also include comments
that describe the semantics of the process,
including the meaning of the link attributes
and their effect on the process.</LI>
<LI>There are three kinds of link process definitions:
simple, implicit, and explicit.</LI></NOTEL></DD>
<DT>4.168 link set:</DT>
<DD>A named set of associations,
declared by a
<HPV>link set declaration</HPV>,
in which elements of the source document type are linked to
elements of the result document type.
For each element link,
source link attributes and result element attributes can be specified.</DD>
<DT>4.169 link set declaration:</DT>
<DD>A markup declaration that defines a link set.</DD>
<DT>4.170 link type declaration:</DT>
<DD>A markup declaration that contains the formal specification
of a link process definition.</DD>
<DT>4.171 link type declaration subset:</DT>
<DD>The entity sets, link attribute sets,
and link set and link set use declarations,
that occur within the declaration subset of a link type declaration.

<NT>The external entity referenced from the link type declaration
is considered part of the declaration subset.</NT></DD>
<DT>4.172 locking shift:</DT>
<DD>A shift function that applies until another locking shift function occurs.</DD>
<DT>4.173 lower-case letter:</DT>
<DD>Character class composed of the 26 unaccented small letters
from
<Q>a</Q> through
<Q>z</Q>.</DD>
<DT>4.174 lower-case name characters:</DT>
<DD>Character class consisting of each additional lower-case

<HPV>name character</HPV>
assigned by the concrete syntax.</DD>
<DT>4.175 lower-case name start characters:</DT>
<DD>Character class consisting of each additional lower-case

<HPV>name start character</HPV>
assigned by the concrete syntax.</DD>
<DT>4.176 LPD:</DT>
<DD>Link process definition.</DD>
<DT>4.177 map:</DT>
<DD>Short reference map.</DD>
<DT>4.178 mark up:</DT>
<DD>To add markup to a document.</DD>
<DT>4.179 marked section:</DT>
<DD>A section of the document that has been identified for a special purpose,
such as ignoring markup within it.</DD>
<DT>4.180 marked section declaration:</DT>
<DD>A markup declaration that identifies a marked section
and specifies how it is to be treated.</DD>
<DT>4.181 marked section end:</DT>
<DD>The closing delimiter sequence of a marked section declaration.</DD>
<DT>4.182 marked section start:</DT>
<DD>The opening delimiter sequence of a marked section declaration.</DD>
<DT>4.183 markup:</DT>
<DD>Text that is added to the data of a document
in order to convey information about it.

<NT>There are four kinds of markup: descriptive markup (tags), references,
markup declarations, and processing instructions.</NT></DD>
<DT>4.184 markup character:</DT>
<DD>An SGML character that,
depending on the context,
could be interpreted either as markup or data.</DD>
<DT>4.185 markup convention:</DT>
<DD>Application convention governing markup,
such as a rule for the formulation of an entity name,
or a preferred subset of allowed short reference delimiters.</DD>
<DT>4.186 (markup) declaration:</DT>
<DD>Markup that controls how other markup of a document is to be interpreted.

<NT>There are 13 kinds:
SGML, entity, element, attribute definition list, notation, document type,
link type, link set, link use, marked section, short reference mapping,
short reference use, and comment.</NT></DD>
<DT>4.187 (markup) minimization feature:</DT>
<DD>A feature of SGML that allows markup to be minimized
by shortening or omitting tags,
or shortening entity references.

<NT>Markup minimization features do not affect the document type definition,
so a minimized document can be sent to a system
that does not support these features by first restoring the omitted markup.
There are five kinds: SHORTTAG, OMITTAG, SHORTREF, DATATAG, and RANK.</NT></DD>
<DT>4.188 markup-scan-in characters:</DT>
<DD>Character class consisting of function characters that
restore markup recognition
if it was suppressed by the occurrence of a markup-scan-out character.</DD>
<DT>4.189 markup-scan-out characters:</DT>
<DD>Character class consisting of function characters that
suppress markup recognition
until the occurrence of a markup-scan-in character or entity end.</DD>
<DT>4.190 markup-scan-suppress characters:</DT>
<DD>A character class consisting of function characters that
suppress markup recognition
for the immediately following character in the same entity (if any).</DD>
<DT>4.191 minimal SGML document:</DT>
<DD>A conforming SGML document that uses the core concrete syntax throughout,
no features, and the reference capacity set.</DD>
<DT>4.192 minimization feature:</DT>
<DD>Markup minimization feature.</DD>
<DT>4.193 model:</DT>
<DD>Content model.</DD>
<DT>4.194 model group:</DT>
<DD>A component of a content model that specifies
the order of occurrence of elements
and character strings in an element's
<HPV>content</HPV>,
as modified by
<HPV>exceptions</HPV>
specified in the
<HPV>content model</HPV> of the element
and in the content models of other open elements.</DD>
<DT>4.195 multicode basic concrete syntax:</DT>
<DD>A multicode variant of the basic concrete syntax
in which markup is not recognized when code extension is in use.</DD>
<DT>4.196 multicode concrete syntax:</DT>
<DD>A concrete syntax that allows code extension control characters
to be SGML characters.</DD>
<DT>4.197 multicode core concrete syntax:</DT>
<DD>A multicode variant of the core concrete syntax
in which markup is not recognized when code extension is in use.</DD>
<DT>4.198 name:</DT>
<DD>A name token whose first character is a name start character.</DD>
<DT>4.199 name character:</DT>
<DD>A character than can occur in a name:
name start characters, digits and others designated by the concrete syntax.</DD>
<DT>4.200 name group:</DT>
<DD>A group whose tokens are required to be names.</DD>
<DT>4.201 name start character:</DT>
<DD>A character that can begin a name:
letters, and others designated be the concrete syntax.</DD>
<DT>4.202 name token:</DT>
<DD>A character string, consisting solely of name characters,
whose length is restricted by the NAMELEN quantity.

<NT>A name token that occurs in a group is also a token;
one that occurs as an attribute value is not.</NT></DD>
<DT>4.203 name token group:</DT>
<DD>A group whose tokens are required to be name tokens.</DD>
<DT>4.204 named character reference:</DT>
<DD>A character reference consisting of a delimited
<HPV>function name</HPV>.</DD>
<DT>4.205 named entity reference:</DT>
<DD>An entity reference consisting of a delimited name of a general entity
or parameter entity (possibly qualified by a document type declaration)
that was declared by an entity declaration.

<NT>A general entity reference can have an undeclared name
if a default entity was declared.</NT></DD>
<DT>4.206 naming rules parameter:</DT>
<DD>A parameter of an SGML declaration that identifies
additions to the standard name alphabet character classes
and specifies the case substitution.</DD>
<DT>4.207 non-SGML character:</DT>
<DD>A character in the document character set
whose coded representation never occurs in an SGML entity.</DD>
<DT>4.208 non-SGML data entity:</DT>
<DD>An entity whose characters are not interpreted in accordance
with this International Standard, and in which, therefore,
no SGML markup can be recognized.

<NT>The interpretation of a non-SGML data entity
is governed by a data content notation
which may be defined by another International Standard.</NT></DD>
<DT>4.209 NONSGML:</DT>
<DD>The class of non-SGML characters,
defined by the document character set.</DD>
<DT>4.210 normalized length (of an attribute specification list):</DT>
<DD>A length calculated by ignoring the actual characters used for delimiting
and separating the components
and counting an extra fixed number per component instead.</DD>
<DT>4.211 notation attribute:</DT>
<DD>An attribute whose value is a
<HPV>notation name</HPV> that identifies
the data content notation of the element's
<HPV>content</HPV>.

<NT>A notation attribute does not apply
when there is an explicit content reference,
as the element's content will be empty.</NT></DD>
<DT>4.212 notation declaration:</DT>
<DD>A markup declaration that associates a name with a notation identifier.</DD>
<DT>4.213 notation identifier:</DT>
<DD>An
<HPV>external identifier</HPV> that identifies a data content notation in
a
<HPV>notation declaration</HPV>.
It can be a
<HPV>public identifier</HPV> if the notation is public, and,
if not, a description or other information sufficient
to invoke a program to interpret the noatation.</DD>
<DT>4.214 notation name:</DT>
<DD>The name assigned to a data content notation by a notation declaration.</DD>
<DT>4.215 number:</DT>
<DD>A name token consisting solely of digits.</DD>
<DT>4.216 number token:</DT>
<DD>A name token whose first character is a digit.

<NT>A number token that occurs in a group is also a token;
one that occurs as an attribute value is not.</NT></DD>
<DT>4.217 numeric character reference:</DT>
<DD>A character reference consisting of a delimited
<HPV>character number</HPV>.</DD>
<DT>4.218 object capacity:</DT>
<DD>The capacity limit for a particular kind of object,
such as entities defined or characters of entity text.</DD>
<DT>4.219 omitted tag minimization parameter:</DT>
<DD>A parameter of an element declaration that specifies
whether a technically valid omission of a start-tag or end-tag
is considered a reportable markup error.</DD>
<DT>4.220 open element:</DT>
<DD>An
<HPV>element</HPV> whose
<HPV>start-tag</HPV> has occurred
(or been omitted through markup minimization),
but whose end-tag has not yet occurred
(or been omitted through markup minimization).</DD>
<DT>4.221 open entity:</DT>
<DD>An entity that has been referenced
but whose entity end has not yet occurred.</DD>
<DT>4.222 open marked section declaration:</DT>
<DD>A marked section declaration whose
<HPV>markup section start</HPV> has occurred
but whose
<HPV>markup section end</HPV> has not yet occurred.</DD>
<DT>4.223 owner identifier:</DT>
<DD>The portion of a public identifier that identifies the owner
or originator of public text.

<NT>There are three kinds: ISO, registered, and unregistered.</NT></DD>
<DT>4.224 parameter:</DT>
<DD>The portion of a markup declaration that is bounded by parameter separators
(whether required or optional).
A parameter can contain other parameters.</DD>
<DT>4.225 parameter entity:</DT>
<DD>
<REV REFID="AMEND1">An entity that can be referenced from a markup declaration parameter.</REV></DD>
<DT>4.226 parameter entity reference:</DT>
<DD>A named entity reference to a parameter entity.</DD>
<DT>4.227 parameter literal:</DT>
<DD>A parameter or token consisting of delimited replaceable parameter data.</DD>
<DT>4.228 parsed character data:</DT>
<DD>Zero or more characters that occur in a context in which text is parsed
and markup is recognized.
They are classified as data characters
because they were not recognized as markup during parsing.</DD>
<DT>4.229 PCDATA:</DT>
<DD>Parsed character data.</DD>
<DT>4.230 PI entity:</DT>
<DD>Processing instruction entity.</DD>
<DT>4.231 point:</DT>
<DD>A unit of capacity measurement,
roughly indicative of relative storage requirements.</DD>
<DT>4.232 procedure:</DT>
<DD>Processing defined by an application to operate on elements
of a particular type.

<NOTEL>
<LI>A single procedure could be assigned with more than one element type,
and/or more than one procedure could operate on the same element type
at different points in the document.</LI>
<LI>A procedure is usually a part of a procedure set.</LI></NOTEL></DD>
<DT>4.233 procedure set:</DT>
<DD>The procedures that are used together for a given application process.

<NT>In SGML applications, a procedure set usually constitutes
the application processing for a link process definition.</NT></DD>
<DT>4.234 processing instruction:</DT>
<DD>Markup consisting of system-specific data
that controls how a document is to be processed.</DD>
<DT>4.235 processing instruction entity:</DT>
<DD>An entity whose text is treated as the
<HPV>system data</HPV>
of a
<HPV>processing instruction</HPV> when referenced.</DD>
<DT>4.236 prolog:</DT>
<DD>The portion of an SGML document or SGML subdocument entity
that contains document type and link type declarations.</DD>
<DT>4.237 proper subelement:</DT>
<DD>A subelement that is permitted by its containing element's model.</DD>
<DT>4.238 ps (separator):</DT>
<DD>A parameter separator, occurring in markup declarations.</DD>
<DT>4.239 public identifier:</DT>
<DD>A minimum literal that identifies public text.

<NOTEL>
<LI>The public identifiers in a document can optionally
be interpretable as formal public identifiers.</LI>
<LI>The system is responsible for converting public identifiers
to system identifiers.</LI></NOTEL></DD>
<DT>4.240 public text:</DT>
<DD>Text that is known beyond the context of a single document
or system environment,
and which can be accessed with a public identifier.

<NOTEL>
<LI>Examples are standard or registered document type definitions,
entity sets, element sets, data content notations,
and other markup constructs (see annex D).</LI>
<LI>Public text is not equivalent to published text;
there is no implication of unrestricted public access.
In particular,
the owner of public text may choose to sell or licence it to others,
or to restrict its access to a single organization.</LI>
<LI>Public text simplifies access to shared constructs,
reduces the amount of text that must be interchanged,
and reduces the chance of copying errors.</LI></NOTEL></DD>
<DT>4.241 public text class:</DT>
<DD>The portion of a text identifier that identifies the SGML markup construct
to which the public text conforms.</DD>
<DT>4.242 public text description:</DT>
<DD>The portion of a text identifier that describes the public text.</DD>
<DT>4.243 public text designating sequence:</DT>
<DD>The portion of a text identifier,
used when public text is a character set,
that contains an ISO2022 escape sequence that designates the set.</DD>
<DT>4.244 public text display version:</DT>
<DD>An optional portion of a text identifier
that distinguishes among public text
that has a common
<HPV>public text description</HPV>
by describing the devices supported or coding scheme used.
If omitted, the public text is not device-dependent.</DD>
<DT>4.245 public text language:</DT>
<DD>The portion of a text identifier that specifies the natural language
in which the public text was written.

<NT>It can be the language of the data, comments, and/or defined names.</NT></DD>
<DT>4.246 quantity:</DT>
<DD>A numeric restriction on some aspect of markup,
such as the maximum length of a name
or the maximum nesting level of open elements.

<NT>Quantities are defined by the abstract syntax,
but specific values are assigned to them by the concrete syntax.</NT></DD>
<DT>4.247 quantity set:</DT>
<DD>A set of assignments of numeric values to quantity names.</DD>
<DT>4.248 ranked element:</DT>
<DD>An element whose
<HPV>generic identifier</HPV> is composed
of a
<HPV>ranked stem</HPV> and a
<HPV>rank suffix</HPV>.
When a ranked element begins,
its
<HPV>rank suffix</HPV> becomes the current rank
for its
<HPV>rank stem</HPV>,
and for the rank stems in the
<HPV>ranked group</HPV> (if any)
of which the
<HPV>rank stem</HPV> is a member.</DD>
<DT>4.249 ranked group:</DT>
<DD>A group of rank stems that share the same current rank.
When any ranked element whose stem is in the group begins,
its
<HPV>rank suffix</HPV> becomes the current rank
for all rank stems in the group.</DD>
<DT>4.250 rank stem:</DT>
<DD>A name from which a generic identifier can be derived
by appending the current rank.</DD>
<DT>4.251 rank suffix:</DT>
<DD>A number that is appended to a rank stem
to form a
<HPV>generic identifier</HPV>.

<NT>The numbers are usually sequential, beginning with 1,
so the resulting generic identifiers
suggest the relative ranks of their elements
(for example, H1, H2, and H3 for level headings elements,
where
<Q>H</Q> is the rank stem).</NT></DD>
<DT>4.252 record:</DT>
<DD>A division of an SGML entity,
bounded by a record start and a record end character,
normally corresponding to an input line on a text entry device.

<NOTEL>
<LI>It is called a
<Q>record</Q> rather than a
<Q>line</Q>
to distinguish it from the output lines created by a text formatter.</LI>
<LI>An SGML entity could consist of many records, a single record,
or text with no record boundary characters at all
(which can be thought of as being part of a record without records,
depending on
whether record boundary characters occur elsewhere in the document).</LI></NOTEL></DD>
<DT>4.253 record boundary (character):</DT>
<DD>The record start (
<HPT>RS</HPT>) or record end (
<HPT>RE</HPT>) character.</DD>
<DT>4.254 record end:</DT>
<DD>A
<HPV>function character</HPV>, assigned by the concrete syntax,
that represents the end of a record.</DD>
<DT>4.255 record start:</DT>
<DD>A
<HPV>function character</HPV>, assigned by the concrete syntax,
that represents the start of a record.</DD>
<DT>4.256 reference:</DT>
<DD>Markup that is replaced by other text,
either an entity or a single character.</DD>
<DT>4.257 reference capacity set:</DT>
<DD>The capacity set that is recognized in this International Standard.</DD>
<DT>4.258 reference concrete syntax:</DT>
<DD>A concrete syntax,
defined in this International Standard,
that is used in all SGML declarations.</DD>
<DT>4.259 reference delimiter set:</DT>
<DD>The delimiter set,
defined in this International Standard,
that is used in the reference concrete syntax.</DD>
<DT>4.260 reference quantity set:</DT>
<DD>The quantity set defined by this International Standard.</DD>
<DT>4.261 reference reserved name:</DT>
<DD>A reserved name defined by this International Standard.</DD>
<DT>4.262 registered owner identifier:</DT>
<DD>An owner identifier that was constructed in accordance with ISO 9070.
It is unique among registered owner identifiers,
and is distinguishable from ISO owner identifiers
and unregistered owner identifiers.</DD>
<DT>4.263 replaceable character data:</DT>
<DD>Character data in which
a
<HPV>general entity reference</HPV> or
<HPV>character reference</HPV>
is recognized and replaced.

<NT>Markup that would terminate
<HPV>replaceable character data</HPV>
is not recognized in the replacement text of entities referenced within it.</NT></DD>
<DT>4.264 replaceable parameter data:</DT>
<DD>Character data in which
a
<HPV>parameter entity reference</HPV> or
<HPV>character reference</HPV>
is recognized and replaced.

<NT>Markup that would terminate
<HPV>replaceable parameter data</HPV>
is not recognized in the replacement text of entities referenced within it.</NT></DD>
<DT>4.265 replacement character:</DT>
<DD>The character that replaces a
<HPV>character reference</HPV>.</DD>
<DT>4.266 replacement text:</DT>
<DD>The text of the entity that replaces an entity reference.</DD>
<DT>4.267 reportable markup error:</DT>
<DD>A failure of a document to conform to this International Standard
when it is parsed with respect to the active document and link types,
<REV REFID="AMEND1">other than a semantic error
(such as a generic identifier that does not identify an element type)</REV>
or:

<OL SPREAD="COMPACT">
<LI>an ambiguous content model;
<REV REFID="AMEND1">
<LI>an exclusion that could change a token's required or optional status
in a model;</LI></REV></LI>
<LI>exceeding a capacity limit;</LI>
<LI>an error in the SGML declaration;
<REV REFID="AMEND1">
<LI>an otherwise allowable omission of a tag that creates an ambiguity;</LI>
<LI>the occurrence of a non-SGML character; or</LI>
<LI>a formal public identifier error.</LI></REV></LI></OL></DD>
<DT>4.268 required attribute:</DT>
<DD>An attribute for which there must always be
an
<HPV>attribute specification</HPV> for the attribute value.</DD>
<DT>4.269 reserved name:</DT>
<DD>A name defined by the concrete syntax, rather than by an application,
such as a markup declaration name.

<NT>Such names appear in this international Standard as syntactic literals
<REV REFID="AMEND1">(see 5.1).</REV></NT></DD>
<DT>4.270 reserved name use parameter:</DT>
<DD>A parameter of the
<HPV>SGML declaration</HPV> that specifies
any replacement in the declared concrete syntax for a reference reserved name.</DD>
<DT>4.271 result document type (of a link):</DT>
<DD>A document type,
a new instance of which is created as the result of a link process.</DD>
<DT>4.272 result element type (of a link):</DT>
<DD>An element that is defined in the result document type declaration.</DD>
<DT>4.273 s (separator):</DT>
<DD>A separator,
consisting of separator characters and other non-printing function characters,
that occurs in markup and in
<HPV>element content</HPV>.</DD>
<DT>4.274 satisfied token:</DT>
<DD>A
<HPV>content token</HPV> whose corresponding content has occurred.</DD>
<DT>4.275 SDATA entity:</DT>
<DD>Specific character data entity.</DD>
<DT>4.276 separator:</DT>
<DD>An
<HPV>s</HPV>,
<HPV>ds</HPV>,
<HPV>ps</HPV>, or
<HPV>ts</HPV>.</DD>
<DT>4.277 separator characters:</DT>
<DD>A character class that consists of function characters
that are allowed in separators and that will be replaced by
<HPT>SPACE</HPT>
in those contexts in which
<HPT>RE</HPT> is replaced by
<HPT>SPACE</HPT>.</DD>
<DT>4.278 SGML:</DT>
<DD>Standard Generalized Markup Language.</DD>
<DT>4.279 SGML application:</DT>
<DD>Rules that apply SGML to a text processing application.
An SGML application includes a formal specification
of the markup constructs used in the application, expressed in SGML.
It can also include a non-SGML definition of semantics,
application conventions, and/or processing.

<NOTEL>
<LI>The formal specification of an SGML application normally includes
document type definitions, data content notations, and entity sets,
and possibly a concrete syntax or capacity set.
If processing is defined by the application,
the formal specification could also include link process definitions.</LI>
<LI>The formal specification of an SGML application constitutes
the common portions of the documents processed by the application.
These common portions are frequently made available as public text.</LI>
<LI>The formal specification is usually accompanied
by comments and/or documentation
that explains the semantics, application conventions,
and processing specifications of the application.</LI>
<LI>An SGML application exists independently of any implementation.
However, if processing is defined by the application,
the non-SGML definition could include application procedures,
implemented in a programming or text-processing language.</LI></NOTEL></DD>
<DT>4.280 SGML character:</DT>
<DD>A character that is permitted in an SGML entity.</DD>
<DT>4.281 SGML declaration:</DT>
<DD>A markup declaration that specifies the character set, concrete syntax,
optional features, and capacity requirements of a document's markup.
It applies to all of the SGML entities of a document.</DD>
<DT>4.282 SGML document:</DT>
<DD>A document that is represented as a sequence of characters,
organized physically into an entity structure
and logically into an element structure,
essentially as described in this International Standard.
An SGML document consists of data characters,
which represent its information content,
and markup characters,
which represent the structure of the data and other information
useful for processing it.
In particular, the markup describes at least one document type definition,
and an instance of a structure conforming to the definition.</DD>
<DT>4.283 SGML document entity:</DT>
<DD>The SGML entity that begins an SGML document.
It contains, at a minimum, an SGML declaration,
a base document type declaration,
and the start and end (if not all) of a base document element.</DD>
<DT>4.284 SGML entity:</DT>
<DD>An entity whose characters are interpreted as markup or data
in accordance with this International Standard.

<NT>There are three types of SGML entity:

<HPV>SGML document entity</HPV>,

<HPV>SGML subdocument entity</HPV>,
and
<HPV>SGML text entity</HPV>.</NT></DD>
<DT>4.285 SGML parser:</DT>
<DD>A program (or portion of a program or a combination of programs)
that recognizes markup in conforming SGML documents.

<NT>If an analogy were to be drawn to programming language processors,
an SGML parser would be said to perform the functions of both
a lexical analyser and a parser with respect to SGML documents.</NT></DD>
<DT>4.286 SGML subdocument entity:</DT>
<DD>An SGML entity
that conforms to the SGML declaration of the SGML document entity,
while conforming to its own document type and link type declarations.
It contains, at a minimum, a base document type declaration
and the start and end of a base document element.</DD>
<DT>4.287 SGML system:</DT>
<DD>A system that includes an SGML parser, an entity manager,
and both or either of:

<OL SPREAD="COMPACT">
<LI>an implementation of one or more SGML applications;
and/or</LI>
<LI>facilities for a user to implement SGML applications,
with access to the SGML parser and entity manager.</LI></OL></DD>
<DT>4.288 SGML text entity:</DT>
<DD>An SGML entity
that conforms to the SGML declaration of the SGML document entity,
and to the document type and link types declarations
to which the entity from which it is referenced conforms.</DD>
<DT>4.289 shift function:</DT>
<DD>In graphic repertoire code extension,
a control sequence or control character that invokes a graphic character set.

<NT>There are two kinds: single shift and locking shift.</NT></DD>
<DT>4.290 short reference:</DT>
<DD>Short reference string.</DD>
<DT>4.291 short reference delimiter role:</DT>
<DD>A delimiter role to which zero or more strings can be assigned
by the concrete syntax.
When a short reference string is recognized,
it is replaced by the general entity
to whose name it is mapped in the current map,
or is treated as a separator or data if it is mapped to nothing.</DD>
<DT>4.292 (short reference) map:</DT>
<DD>A named set of associations,
declared by a
<HPV>short reference mapping declaration</HPV>,
in which each short reference delimiter is mapped to a general entity name
or to nothing.</DD>
<DT>4.293 short reference mapping declaration:</DT>
<DD>A markup declaration that defines a short reference map.</DD>
<DT>4.294 short reference set:</DT>
<DD>A set of short reference mapping, short reference use,
and entity declarations that are used together.

<NT>A short reference set can be public text.</NT></DD>
<DT>4.295 short reference (string):</DT>
<DD>A character string assigned to the short reference delimiter role
by the concrete syntax.</DD>
<DT>4.296 short reference use declaration:</DT>
<DD>A markup declaration that associates a short reference map
with one ore more element types,
or identifies a new current map for the current element.</DD>
<DT>4.297 shunned character (number):</DT>
<DD>A character number, identified by a concrete syntax,
that should be avoided in documents employing the syntax
because some systems might erroneously treat it as a control character.</DD>
<DT>4.298 significant SGML character:</DT>
<DD>A
<HPV>markup character</HPV> or
<HPV>minimum data</HPV> character.</DD>
<DT>4.299 simple link (process definition):</DT>
<DD>A link process definition in which
the result element types and their attributes
are all implied by the application,
and only one set of link attribute values can be specified.
The source document type must be the base.</DD>
<DT>4.300 single shift:</DT>
<DD>A shift function that applies to the following character only.</DD>
<DT>4.301 source document type (of a link):</DT>
<DD>A document type, an existing instance of which is the source of a link process.</DD>
<DT>4.302 source element type (of a link):</DT>
<DD>An element type that is defined in the source document type declaration.</DD>
<DT>4.303 space:</DT>
<DD>A
<HPV>function character</HPV>, assigned by the concrete syntax,
that represents a space.</DD>
<DT>4.304 specific character data entity:</DT>
<DD>An entity whose text is treated as
<HPV>character data</HPV> when referenced.
The text is dependent on a specific system, device, or application process.

<NT>A specific character data entity would normally be redefined
for different applications, systems, or output devices.</NT></DD>
<DT>4.305 Standard Generalized Markup Language:</DT>
<DD>A language for document representation that formalizes markup
and frees it of system and processing dependencies.</DD>
<DT>4.306 start-tag:</DT>
<DD>Descriptive markup that identifies the start of an element
and specifies its generic identifier and attributes.</DD>
<DT>4.307 status keyword:</DT>
<DD>A marked section declaration parameter that specifies
whether the marked section is to be ignored, and,
if not, whether it is to be treated as character data,
replaceable character data, or normally.</DD>
<DT>4.308 string:</DT>
<DD>Character string.</DD>
<DT>4.309 subelement:</DT>
<DD>An element that occurs in the content of another element
(the
<Q>containing element</Q>)
in such a way that the subelement begins
when the containing element is the current element.</DD>
<DT>4.310 syntax-reference character set:</DT>
<DD>A character set,
designated by a concrete syntax and known to all potential users of the syntax,
that contains every significant SGML character.
It enables the concrete syntax to be defined
without regard to the particular document or system character sets
with which it might be used.</DD>
<DT>4.311 system character set:</DT>
<DD>The character set used in an SGML system.</DD>
<DT>4.312 system declaration:</DT>
<DD>A declaration,
included in the documentation for a conforming SGML system,
that specifies the features, capacity set,
concrete syntaxes, and character set that the system supports,
the data content notations that it can interpret,
and any validation services that it can perform.</DD>
<DT>4.313 system identifier:</DT>
<DD>System data that specifies the file identifier, storage location,
program invocation, data stream position,
or other system-specific information that locates an external entity.</DD>
<DT>4.314 tag:</DT>
<DD>Descriptive markup.

<NT>There are two kinds: start-tag and end tag.</NT></DD>
<DT>4.315 target element:</DT>
<DD>An element whose
<HPV>generic identifier</HPV> is specified
in a
<HPV>data tag group</HPV>.</DD>
<DT>4.316 text:</DT>
<DD>Characters.

<NT>The characters could have their normal character set meaning,
or they could be interpreted in accordance with a data content notation
as the representation of graphics, images, etc.</NT></DD>
<DT>4.317 text identifier:</DT>
<DD>The portion of a public identifier that identifies a public text
so that it can be distinguished from any other public text
with the same owner identifier.

<NT>It consists of
a
<HPV>public text class</HPV>,
an optional
<HPV>unavailable text indicator</HPV>,
a
<HPV>public text description</HPV>,
a
<HPV>public text language</HPV>,
and an optional
<HPV>public text display version</HPV>.</NT></DD>
<DT>4.318 text processing application:</DT>
<DD>A related set of processes performed on documents of related types.

<NT>Some examples are:

<OL SPREAD="COMPACT">
<LI>Publication of technical manuals for software developer:
document types include installation, operation, and maintenance manuals;
processes include creation, revision, formatting and page layout
for a variety of output devices.</LI>
<LI>Preparation of manuscripts by independent authors
for members of an association of publishers:
document types include book, journal, and article;
creation is the only defined process,
as each publisher has its own methods of formatting and printing.</LI>
<LI>Office correspondence:
document types include memos, mail logs, and reports;
processes include creation, revision, simple formatting,
storage and retrieval, memo log update and report generation.</LI></OL></NT></DD>
<DT>4.319 token:</DT>
<DD>The portion of a group,
including a complete nested group (but not a
<HPV>connector</HPV>),
that is bounded by token separators (whether required or optional).</DD>
<DT>4.320 total capacity:</DT>
<DD>A limit on the sum of all object capacities.</DD>
<DT>4.321 ts (separator):</DT>
<DD>A token separator, occurring in groups.</DD>
<DT>4.322 type definition:</DT>
<DD>Document type definition.</DD>
<DT>4.323 unavailable public text:</DT>
<DD>Public text that is available only to a limited population,
selected by its owner.</DD>
<DT>4.324 unique identifier:</DT>
<DD>A
<HPV>name</HPV> that uniquely identifies an element.</DD>
<DT>4.325 unregistered owner identifier:</DT>
<DD>An owner identifier that can be distinguished from
registered owner identifiers and ISO owner identifiers.
As it is not constructed according to a registration standard,
it could duplicate another unregistered owner identifier.</DD>
<DT>4.326 upper-case letters:</DT>
<DD>Character class composed of the 26 capital letters
from
<Q>A</Q> through
<Q>Z</Q>.</DD>
<DT>4.327 upper-case name characters:</DT>
<DD>Character class consisting of the upper case forms
of the corresponding lower-case name characters.</DD>
<DT>4.328 upper-case name start characters:</DT>
<DD>Character class consisting of the upper case forms
of the corresponding lower-case name start characters.</DD>
<DT>4.329 validating SGML parser:</DT>
<DD>A conforming SGML parser that can find and report a reportable markup error
if (and only if) one exists.</DD>
<DT>4.330 variant concrete syntax:</DT>
<DD>A concrete syntax other than
the reference concrete syntax or core concrete syntax.</DD>
<DT>4.331 variant (conforming) SGML document:</DT>
<DD>A conforming SGML document that uses a variant concrete syntax.</DD>
<DT>4.332 virtual character set:</DT>
<DD>In graphic repertoire code extension, one of the character sets,
known as G0, G1, G2 or G3,
that represents the mapping of a real graphic character set,
designated by an escape sequence,
to a document code set position previously announced by an escape sequence.</DD></DL>
<H1>Notation</H1>
<LOSTDATA></LOSTDATA>
<NT>This clause describes the notation used in this International Standard
to define the Standard Generalized Markup Language.
This notation is not part of SGML itself
(although there are some similarities between them),
and therefore this clause should be considered as affecting only
the presentation of this International Standard, not the substance.</NT>
<P>The SGML abstract syntax is specified by formal syntax productions,
each of which defines a
<Q>syntactic variable</Q>.
A production consists of a reference number (in square brackets),
the name of the syntactic variable being defined, an equals sign,
and an expression that constitutes the definition.
<PROD>[number] syntactic variable = expression</PROD></P>
<P>The expression is composed of
one or more
<Q>syntactic tokens</Q>,
parenthesized expressions,
and symbols that define the ordering and selection among them.</P>
<H2>Syntactic Tokens</H2>
<LOSTDATA></LOSTDATA>
<P>The following list shows the syntactic token types
using the typographic conventions employed for them
in this International Standard,
together with the source of their definitions:</P>
<P>
<HPV>syntactic variable</HPV>.
A syntactic token that is defined by a syntax production.</P>
<P>"SYNTACTIC LITERAL".
A syntactic token consisting of a reserved name that is to be entered
in markup exactly as it is shown in the syntax production,
except that corresponding lower-case letters can be used
if upper-case translation of general names is specified by the concrete syntax.
Syntactic literals are defined whenever they occur in a syntax production,
and the definition is applicable only in the context of that production.</P>
<P>
<HPD>delimiter role</HPD>.
A syntactic token that represents a delimiter string.
Delimiter roles are defined in figure 3,
which also lists the strings assigned to general delimiter roles
by the reference concrete syntax.
Strings assigned to the
<HPD>shortref</HPD> delimiter role
are shown in figure 4.</P>
<P>
<HPT>TERMINAL VARIABLE</HPT>.
A syntactic token that represents a character class
whose members are not necessarily the same in all SGML documents.
Terminal variables whose members are assigned by the concrete syntax
are defined in figure 2.
(The
<HPT>NONSGML</HPT> variable,
whose members are assigned by the document character set,
is defined in 13.1.2.)</P>
<P>
<HPC>Terminal Constant</HPC>.
A syntactic token that represents either an entity end signal,
or a character class whose members are the same in all SGML documents.
Terminal constants are defined in figure 1.</P>
<H2>Ordering and Selection Symbols</H2>
<LOSTDATA></LOSTDATA>
<P>If there is more than one syntactic token in an expression,
the ordering and selection among them is determined by symbols
that connect them, as follows:

<DL SPREAD="COMPACT" TERMHI="0" TSIZE="4">
<DT>,</DT>
<DD>All must occur, in the order shown.</DD>
<DT>&amp;</DT>
<DD>All must occur, in any order.</DD>
<DT>|</DT>
<DD>One and only one must occur.</DD></DL></P>
<P>Each selected syntactic token must occur once and only once
unless the contrary is indicated by a suffix
consisting of one of the following symbols:

<DL SPREAD="COMPACT" TERMHI="0" TSIZE="4">
<DT>?</DT>
<DD>Optional (0 or 1 time).</DD>
<DT>+</DT>
<DD>Required and repeatable (1 or more times).</DD>
<DT>*</DT>
<DD>Optional and repeatable (0 or more times).</DD></DL></P>
<P>
<REV REFID="AMEND1">Successive instances of a syntactic token
are deemed to be repetitions of a repeatable token,
where permissible,
rather than instances of multiple tokens.</REV></P>
<P>The occurrence suffixes are applied first, then the ordering connectors.
Parentheses can be used as in mathematics to change these priorities.</P>
<H1>Entity Structure</H1>
<LOSTDATA></LOSTDATA>
<H2>SGML Document</H2>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>SGML document</HPV> is physically organized in an entity structure.
The first entity is an
<HPV>SGML document entity</HPV>;
it contains entity references that indicate where the other entities
belong with respect to it.
<PROD>[1] SGML document =

<HPV>SGML document entity</HPV>,
(
<HPV>SGML subdocument entity</HPV> |

<HPV>SGML text entity</HPV> |

<REV REFID="AMEND1">
<HPV>character data entity</HPV> |

<HPV>specific character data entity</HPV> |</REV>

<HPV>non-SGML data entity</HPV>)*</PROD>

<NOTEL>
<LI>This International Standard does not constrain
the physical organization of the document
within the data stream, message handing protocol, file system, etc.,
that contains it.
In particular,
separate entities could occur in the same physical object,
a single entity could be divided between multiple objects,
and the objects could occur in any order.</LI>
<LI>This International Standard does not constrain
the characters that can occur in a data stream outside of the SGML entities.
Such characters will be interpreted
according to applicable standards and conventions.</LI>
<LI>The SGML Document Interchange Format (SDIF)
standardized in ISO 9069 allows an SGML document
to be managed conveniently as a single object,
while still preserving the entity structure.</LI></NOTEL></P>
<H2>SGML Entities</H2>
<PROD>[2] SGML document entity =

<REV REFID="AMEND1">
<HPV>s</HPV>*,
<HPV>SGML declaration</HPV>,</REV>

<HPV>prolog</HPV>,
<HPV>document instance set</HPV>,
<HPC>Ee</HPC></PROD>
<PROD>[3] SGML subdocument entity =

<REV REFID="AMEND1">
<HPV>prolog</HPV>,
<HPV>document instance set</HPV>,
<HPC>Ee</HPC></REV></PROD>
<PROD>[4] SGML text entity =

<HPV>SGML character</HPV>*,
<HPC>Ee</HPC></PROD>
<LOSTDATA></LOSTDATA>
<P>The characters of an SGML entity are parsed in accordance with
this International Standard to recognize the

<HPV>SGML declaration</HPV>,

<HPV>prolog</HPV>, and

<HPV>document instance set</HPV>,
and their constituent parts.</P>
<P>Each
<HPV>SGML character</HPV> is parsed in the order it occurs,
in the following manner:

<OL SPREAD="COMPACT">
<LI>The character is tested to see if it is part of a delimiter string (see 9.6).
If a general delimiter string is recognized,
<REV REFID="AMEND1">ensuing  markup is parsed (see item d, below).</REV>
If a
<HPV>short reference</HPV> is recognized,
it is treated as specified in 9.4.6.</LI>
<LI>If the character is not part of a delimiter string,
or it is part of an unmapped short reference,
it is tested to see if it is a separator;
if so, it is ignored.</LI>
<LI>If the character is not part of a delimiter or a separator,
it is treated as data.
<REV REFID="AMEND1">
<LI>Within markup, a character is tested to see
if it is part of a delimiter string, a separator,
delimited literal data, or a token (see 9.6.6).</LI></REV></LI></OL></P>
<P>If an
<HPV>SGML character</HPV> is a
<HPV>function character</HPV>,
its function is performed in addition to any other treatment
it may receive.</P>
<H3>S Separator</H3>
<PROD>[5] s =
<HPT>SPACE</HPT> |
<HPT>RE</HPT> |
<HPT>RS</HPT> |
<HPT>SEPCHAR</HPT></PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>SGML character</HPV> is not considered part of an
<HPV>s</HPV>
if it can be interpreted as some other markup.
If it is considered part of an
<HPV>s</HPV> it is ignored.</P>
<H3>Entity End</H3>
<LOSTDATA></LOSTDATA>
<P>An
<HPC>Ee</HPC> is an entity end signal.</P>
<NT>An
<HPC>Ee</HPC> is not a character and is never treated as data.
It can occur only where expressly permitted.</NT>
<P>A system can represent an
<HPC>Ee</HPC> in any manner
that will allow it to be distinguished from SGML characters.</P>
<NT>For example, an
<HPC>Ee</HPC> could be represented by the bit combination
of a non-SGML character, if any have been assigned.</NT>
<H3>Implied SGML declaration</H3>
<LOSTDATA></LOSTDATA>
<P>While a document is processed exclusively  by a single system,
the system can imply the
<HPV>SGML declaration</HPV>.
The declaration must be present explicitely, however,
if the document is subsequently sent to another system.</P>
<H2>Data Entities</H2>
<REV REFID="AMEND1">
<PROD>[5.1] character data entity =

<HPV>SGML character</HPV>*,
<HPC>Ee</HPC></PROD>

<PROD>[5.2] specific character data entity =

<HPV>SGML character</HPV>*,
<HPC>Ee</HPC></PROD></REV>
<PROD>[6] non-SGML data entity =

<HPV>character</HPV>*,
<HPC>Ee</HPC></PROD>
<LOSTDATA></LOSTDATA>
<NT>
<REV REFID="AMEND1">A
<HPV>data entity</HPV> is declared with a notation parameter</REV>that identifies how the data is to be interpreted.</NT>
<H1>Element Structure</H1>
<LOSTDATA></LOSTDATA>
<H2>Prolog</H2>
<PROD>[7] prolog =

<HPV>other prolog</HPV>*,

<HPV>base document type declaration</HPV>,
(
<HPV>document type declaration</HPV> |

<HPV>other prolog</HPV>)*,
(
<HPV>link type declaration</HPV> |
<HPV>other prolog</HPV>)*</PROD>
<PROD>[8] other prolog =

<HPV>comment declaration</HPV> |

<HPV>processing instruction</HPV> |
<HPV>s</HPV></PROD>
<PROD>[9] base document type declaration =

<HPV>document type declaration</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>An SGML document or subdocument entity conforms to
the document type and link process definitions
that are specified by the document type and link type declarations,
respectively, in its
<HPV>prolog</HPV>.
An SGML text entity conforms to the
<HPV>prolog</HPV>
to which the entity from which it is referenced conforms.
<REV REFID="AMEND1">An SGML entity is parsed with respect to its base document type
and any active link types
unless one or more active document types are identified,
in which case it is parsed only with respect to them.</REV></P>
<NT>The system normally identifies the active document type and link types
to the SGML parser during initialization (see clause F.2).</NT>
<P>Document type declarations in addition to the base are permitted
only if "CONCUR YES" or "EXPLICIT YES"
is specified on the
<HPV>SGML declaration</HPV>.</P>
<P>There can be an active document type only if
"CONCUR YES" is specified on the
<HPV>SGML declaration</HPV>.
The base document type can be active only
if at least one other document type is active.</P>
<NT>Parsing with respect to the base document type alone
is accomplished by not identifying an active document type.</NT>
<REV REFID="AMEND1">
<P>There can be an active link type for an entity if
it has at least one link process definition.
The possibility of simultaneous active link types
depends on the class of link type, as follows:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>simple</DT>
<DD>More than one simple link type can be active,
in addition to any implicit and explicit links.</DD>
<DT>implicit</DT>
<DD>Only one can be active.</DD>
<DT>explicit</DT>
<DD>More than one can be active only
if they form a chain of processes in which
the source document type of the first is the base document type,
the source document type of the second is the result document type of the first,
etc.
The last link type in the chain can be an implicit link.</DD></DL></P></REV>
<H2>Document Element</H2>
<PROD>[10] document instance set =

<REV REFID="AMEND1">
<HPV>base document element</HPV>,
<HPV>other prolog</HPV>*</REV></PROD>
<PROD>[11] base document element =

<HPV>document element</HPV></PROD>
<PROD>[12] document element =

<HPV>element</HPV></PROD>
<LOSTDATA></LOSTDATA>
<H3>Limits</H3>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">Instance of document type declarations other than the base</REV>are permitted only to the limit specified
on the "CONCUR" parameter of the
<HPV>SGML declaration</HPV>.</P>
<H2>Element</H2>
<PROD>[13] element =

<HPV>start-tag</HPV>?,
<HPV>content</HPV>,
<HPV>end-tag</HPV>?</PROD>
<LOSTDATA></LOSTDATA>
<P>If an element has a
<HPV>declared content</HPV> of "EMPTY",
or an explicit content reference,
the
<HPV>end-tag</HPV> must be omitted.</P>
<NT>This requirement has nothing to do with markup minimization.</NT>
<H3>Omitted Tag Minimization</H3>
<REV REFID="AMEND1">
<P>A tag can be omitted only as provided in this sub-sub-clause,
and only if the omission would not create an ambiguity,
and if "OMITTAG YES" is specified on the
<HPV>SGML declaration</HPV>.</P></REV>
<LOSTDATA></LOSTDATA>
<NT>A document type definition may consider a technically valid omission
to be a markup error (see 11.2.2).</NT>
<H4>Start-tag Omission</H4>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>start-tag</HPV> can be omitted
if the element is a contextually required element
and any other elements that could occcur are contextually optional elements,
except if:

<OL SPREAD="COMPACT">
<LI>the element type has a required attribute or
<HPV>declared content</HPV>;
or</LI>
<LI>the content of the instance of the element is empty.</LI></OL></P>
<P>An omitted
<HPV>start-tag</HPV> is treated as having an empty

<HPV>attribute specification list</HPV>.</P>
<P>
<REV REFID="AMEND1">It is ambiguous to omit the
<HPV>start-tag</HPV> of an element
whose contents begins with a short reference string
whose mapping is changed by the element's associated short reference map.</REV></P>
<H4>End-tag Omission</H4>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">The
<HPV>end-tag</HPV> can be omitted for an element</REV>that is followed either

<OL SPREAD="COMPACT">
<LI>
<REV REFID="AMEND1">by the end of an
<HPV>SGML document entity</HPV> or

<HPV>SGML subdocument entity</HPV>;
or</REV></LI>
<LI>by the
<HPV>end-tag</HPV> of another open
<HPV>element</HPV>;
or</LI>
<LI>by an
<HPV>element</HPV> or
<HPV>SGML character</HPV>
that is not allowed in its
<HPV>content</HPV>.

<NT>An element that is not allowed because it is an exclusion
has the same effect as one that is not allowed
because no token appears for it in the model group.</NT></LI></OL></P>
<H3>Data Tag Minimization</H3>
<LOSTDATA></LOSTDATA>
<P>If "DATATAG YES" is specified on the
<HPV>SGML declaration</HPV>,
<REV REFID="AMEND1">data can serve as the
<HPV>end-tag</HPV> of an element that is</REV>
the corresponding content of a data tag group.</P>
<P>The data content of the (target) element and its subelements
is scanned for a string that conforms to one of the
data tag templates in the element's
<HPV>data tag pattern</HPV>.
That string, plus any succeeding characters that conform to
the
<HPV>data tag padding template</HPV>,
are considered the element's data tag.
The data tag is treated both
as the
<HPV>end-tag</HPV> of the target element and
as
<HPV>character data</HPV> in its containing element.</P>
<NT>A
<HPV>generic identifier</HPV> that occurs as a target element
in a
<HPV>data tag group</HPV> could also occur in other contexts
as an
<HPV>element token</HPV>.
In those contexts, it would not be scanned for a data tag.
It could also occur in other data tag groups,
possibly with different data tag patterns.</NT>
<P>The data content of a target element is scanned a character at a time.
At each character, the longest possible
<HPV>data tag template</HPV>
in the
<HPV>data tag pattern</HPV> is matched.
If more than one target element is an open element,
then at each character the templates of
the most recently opened target element are tested first.
If there is no match,
the templates of the next most recently opened target element are tested,
and so on.</P>
<NT>A data tag will therefore terminate
the most recently opened target element
whose data tag pattern it satisfies.</NT>
<P>The matching of a
<HPV>data tag pattern</HPV> to the content
occurs after recognition of markup
and replacement of references in the content,
but before any
<HPT>RE</HPT> or
<HPT>RS</HPT>
characters are ignored.</P>
<NT>The
<HPV>data tag pattern</HPV> can therefore contain
named character references to
<HPT>RE</HPT> and
<HPT>RS</HPT>.</NT>
<P>A data tag cannot be recognized in any context in which

<HPV>end-tags</HPV> are not recognized;
for example, within a CDATA marked section.</P>
<P>In matching the
<HPV>data tag padding template</HPV>,
the template characters can be omitted, used once, or repeated indefinitely.
The last (or only) use can stop short of the full template.
<REV REFID="AMEND1">
<P>An element that has a data tag is not treated
as having an omitted
<HPV>end-tag</HPV>.</P></REV></P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The number of open elements cannot exceed the "TAGLVL" quantity.</P>
<P>The length of a data tag cannot exceed the "DTAGLEN" quantity.</P>
<H2>Start-tag</H2>
<PROD>[14] start-tag =
(
<HPD>stago</HPD>,

<HPV>document type specification</HPV>,

<HPV>generic identifier specification</HPV>,

<HPV>attribute specification list</HPV>,

<HPV>s</HPV>*,
<HPD>tagc</HPD>) |

<HPV>minimized start-tag</HPV></PROD>
<LOSTDATA></LOSTDATA>
<H3>Minimization</H3>
<PROD>[15] minimized start-tag =

<HPV>empty start-tag</HPV> |

<HPV>unclosed start-tag</HPV> |

<HPV>net-enabling start-tag</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>start-tag</HPV> can be a
<HPV>minimized start-tag</HPV>
only if "SHORTTAG YES" is specified on the
<HPV>SGML declaration</HPV>.</P>
<H4>Empty Start-tag</H4>
<PROD>
<REV REFID="AMEND1">[16] empty start-tag =
<HPD>stago</HPD>,
<HPD>tagc</HPD></REV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>start-tag</HPV> can be an
<HPV>empty start-tag</HPV>
only if the
<HPV>element</HPV> is in the base document instance,
in which case the tag's
<HPV>generic identifier specification</HPV>
is assumed to be:

<OL SPREAD="COMPACT">
<LI>if "OMITTAG YES" is specified on the
<HPV>SGML declaration</HPV>,
the
<HPV>generic identifier</HPV> of the most recently
started open element in the base document type;
or</LI>
<LI>if "OMITTAG NO" is specified on the
<HPV>SGML declaration</HPV>,
the
<HPV>generic identifier</HPV> of the most recently
ended element in the base document type;
or</LI>
<LI>if there was no such previous applicable element,
the
<HPV>generic identifier</HPV> of the
<HPV>document element</HPV>.</LI></OL></P>
<P>An
<HPV>empty start-tag</HPV> is treated as having an
empty
<HPV>attribute specification list</HPV>.
<REV REFID="AMEND1">
<NT>A
<HPV>generic identifier specification</HPV> is implied for
an
<HPV>empty start-tag</HPV> prior to determine whether any tags
were omitted before it.</NT></REV></P>
<H4>Unclosed Start-tag</H4>
<PROD>[17] unclosed start-tag =

<HPD>stago</HPD>,

<HPV>document type specification</HPV>,

<HPV>generic identifier specification</HPV>,

<HPV>attribute specification list</HPV>,

<HPV>s</HPV>*</PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>start-tag</HPV> can be an
<HPV>unclosed start-tag</HPV>
only if it is followed immediately by the character string assigned to
the
<HPD>stago</HPD> or
<HPD>etago</HPD> delimiter role,
regardless of whether the string begins a valid
delimiter-in-context sequence.</P>
<H4>NET-enabling Start-tag</H4>
<REV REFID="AMEND1">
<PROD>[18] net-enabling start-tag =

<HPD>stago</HPD>,

<HPV>generic identifier specification</HPV>,

<HPV>attribute specification list</HPV>,

<HPV>s</HPV>*,
<HPD>net</HPD></PROD></REV>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>start-tag</HPV> can be a
<HPV>net-enabling start-tag</HPV>
only if its
<HPV>element</HPV> is in the base document instance.</P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The length of a
<HPV>start-tag</HPV>,
before interpretation of attribute value literals
in the
<HPV>attribute specification list</HPV> and exclusive
of the
<HPD>stago</HPD> and
<HPD>tagc</HPD> or
<HPD>net</HPD> delimiters,
cannot exceed the "TAGLEN" quantity.</P>
<H2>End-tag</H2>
<PROD>[19] end-tag =
(
<HPD>etago</HPD>,

<HPV>document type specification</HPV>,

<HPV>generic identifier specification</HPV>,

<HPV>s</HPV>*,
<HPD>tagc</HPD>) |

<HPV>minimized end-tag</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>end-tag</HPV> ends the most recently started open
<HPV>element</HPV>,
within the instance of the document type
specified by the
<HPV>document type specification</HPV>,
whose generic identifier is
specified by the
<HPV>generic identifier specification</HPV>.</P>
<H3>Minimization</H3>
<PROD>[20] minimized end-tag =

<HPV>empty end-tag</HPV> |

<HPV>unclosed end-tag</HPV> |

<HPV>null end-tag</HPV></PROD>
<LOSTDATA>An
<HPV>end-tag</HPV> can be a
<HPV>minimized end-tag</HPV>
only if "SHORTTAG YES" is specified on the
<HPV>SGML declaration</HPV>.</LOSTDATA>
<H4>Empty End-tag</H4>
<REV REFID="AMEND1">
<PROD>[21] empty end-tag =
<HPD>etago</HPD>,
<HPD>tagc</HPD></PROD></REV>
<LOSTDATA></LOSTDATA>
<P>If an
<HPV>end-tag</HPV> is an
<HPV>empty end-tag</HPV>,
its
<HPV>generic identifier</HPV> is that of the most recently
started open element in the base document instance.
If there was no such element, the
<HPV>end-tag</HPV> is an error.</P>
<H4>Unclosed End-tag</H4>
<PROD>[22] unclosed end-tag =

<HPD>etago</HPD>,

<HPV>document type specification</HPV>,

<HPV>generic identifier specification</HPV>,

<HPV>s</HPV>*</PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>end-tag</HPV> can be an
<HPV>unclosed end-tag</HPV>
only if it is followed immediately by the character string assigned to
the
<HPD>stago</HPD> or
<HPD>etago</HPD> delimiter role,
regardless of whether the string begins a valid
delimiter-in-context sequence.</P>
<H4>Null End-tag</H4>
<PROD>[23] null end-tag =

<HPD>net</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPD>net</HPD> is recognized as a
<HPV>null end-tag</HPV>
only if the
<HPV>start-tag</HPV> of an open element
in the base document type was a
<HPV>net-enabling start-tag</HPV>.
It is assumed to be the
<HPV>end-tag</HPV>
of the most recently started such element.</P>
<H2>Content</H2>
<PROD>[24] content =

<HPV>mixed content</HPV> |

<HPV>element content</HPV> |

<HPV>replaceable character data</HPV> |

<HPV>character data</HPV></PROD>
<PROD>[25] mixed content =
(
<HPV>data character</HPV> |
<HPV>element</HPV> |

<HPV>other content</HPV>)*</PROD>
<PROD>[26] element content =
(
<HPV>element</HPV> |
<HPV>other content</HPV> |
<HPV>s</HPV>)*</PROD>
<PROD>[27] other content =

<HPV>comment declaration</HPV> |

<HPV>short reference use declaration</HPV> |

<REV REFID="AMEND1">
<HPV>link set use declaration</HPV> |</REV>

<HPV>processing instruction</HPV> |

<HPD>shortref</HPD> |

<HPV>character reference</HPV> |

<HPV>general entity reference</HPV> |

<HPV>marked section declaration</HPV> |

<HPC>Ee</HPC></PROD>
<LOSTDATA></LOSTDATA>
<P>An element's
<HPV>declared content</HPV> or
<HPV>content model</HPV>
determines which of the four types of
<HPV>content</HPV> it has,
or whether it is empty,
except that the
<HPV>content</HPV> must be empty
if the element has an explicit content reference.</P>
<P>The
<HPV>content</HPV> of an element declared to be

<HPV>character data</HPV> or
<HPV>replaceable character data</HPV>
is terminated only by an
<HPD>etago</HPD> delimiter-in-context
(which need not open a valid
<HPV>end-tag</HPV>)
or a valid
<HPD>net</HPD>.
Such termination is an error if it would have been an error
had the
<HPV>content</HPV> been
<HPV>mixed content</HPV>.</P>
<NT>Content characters could be classed as data content for either of two reasons:

<OL>
<LI>Declared character data.

<P>The element's entire content was declared to be

<HPV>character data</HPV> or
<HPV>replaceable character data</HPV>
by the
<HPV>declared content</HPV> parameter
of the
<HPV>element declaration</HPV>.</P></LI>
<LI>Parsed character data.

<P>The element was declared to have
<HPV>mixed content</HPV>,
and an
<HPV>SGML character</HPV> within it
was parsed as data because it was not recognized as markup.</P></LI></OL></NT>
<H3>Record Boundaries</H3>
<LOSTDATA></LOSTDATA>
<P>If an
<HPT>RS</HPT> in
<HPV>content</HPV> is not interpreted as markup,
it is ignored.</P>
<P>Within
<HPV>content</HPV>, an
<HPT>RE</HPT>
remaining after replacement of all references and recognition of markup
is treated as data unless its presence can be attributed solely to markup.
That is:

<OL>
<LI>The first
<HPT>RE</HPT> in an element is ignored
if no
<HPT>RS</HPT>, data, or proper subelement preceded it.</LI>
<LI>The last
<HPT>RE</HPT> in an element is ignored
if no data or proper subelement follows it.</LI>
<LI>An
<HPT>RE</HPT>
that does not immediately follow an
<HPT>RS</HPT> or
<HPT>RE</HPT>
is ignored
if no data or proper subelement intervened.</LI></OL>
<REV REFID="AMEND1">
<NT>The determination that an
<HPT>RE</HPT> is data
is made during recognition of markup.
Markup recognition,
which includes recognition of omitted tags,
occurs before the determination of
whether an
<HPT>RE</HPT> can be ignored according to the above rules.
This sequence produces intuitive results in the normal case,
where data can occur anywhere in the
<HPV>content</HPV> of an element,
as in:

<XMP>(quote | #PCDATA)*</XMP>

<P>In content models where the occurrence of data is restricted, however,
as in:

<XMP>(x, #PCDATA)</XMP>
the situations described in item a) and b)
would be treated as errors during markup recognition.
The use of such content models is normally unnecessary
and therefore not normally recommended (see 11.2.4).</P></NT></REV></P>
<P>In applying these rules to an element, subelement content is ignored;
that is, a proper or included subelement is treated as an atom
that ends in the same record in which it begins.</P>
<NT>For example, in

<XMP>record 1<outer><sub>
record 2</sub>
</outer>record 3</XMP>
the first
<HPT>RE</HPT> in the outer element is at the end of record 2.
It is treated as data if
<Q>sub</Q> is a proper subelement of
<Q>outer</Q>,
but it is ignored if
<Q>sub</Q> is an included element,
because no data or proper subelement
would have preceded it in the outer element.

<P>In either case, the first
<HPT>RE</HPT> in the subelement
is at the end of record 1;
it is ignored because no data or proper subelement
preceded it in the subelement.</P></NT>
<P>An
<HPT>RE</HPT> is deemed to occur immediately
prior to the first data or proper subelement that follows it
(that is,
after any intervening markup declaration,
processing instruction, or included subelement).

<NOTEL>
<LI>A specific character data entity, non-SGML data entity,
or SGML subdocument entity, is treated as data,
while a processing instruction entity is not.</LI>
<LI>Although the handling of records boundaries is defined by SGML,
there is no such requirement that SGML documents must be organized in records.</LI>
<LI>No entity, including the
<HPV>SGML document entity</HPV> and external entities,
is deemed to start with an
<HPT>RS</HPT> or end with an
<HPT>RE</HPT>
unless it really does.</LI></NOTEL></P>
<H2>Document Type Specification</H2>
<PROD>[28] document type specification =

<HPV>name group</HPV>?</PROD>
<LOSTDATA></LOSTDATA>
<P>Markup containing a
<HPV>document type specification</HPV>
is processed only if:

<OL SPREAD="COMPACT">
<LI>a
<HPV>name</HPV> in the
<HPV>name group</HPV>
is that of an active document type;
or</LI>
<LI>there is no
<HPV>name group</HPV>
(that is, the
<HPV>document type specification</HPV> is empty).</LI></OL></P>
<NT>An effect of this requirement is that markup
with an empty document type specification (that is, no
<HPV>name group</HPV>)
will apply to all document instances (or the only one).</NT>
<P>A
<HPV>name group</HPV> can be specified
<REV REFID="AMEND1">only if "CONCUR YES"</REV>
is specified on the
<HPV>SGML declaration</HPV>.</P>
<H2>Generic Identifier (GI) Specification</H2>
<PROD>[29] generic identifier specification =

<HPV>generic identifier</HPV> |
<HPV>rank stem</HPV></PROD>
<PROD>[30] generic identifier =
<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>generic identifier</HPV> is valid
<REV REFID="AMEND1">in a
<HPV>generic identifier specification</HPV></REV>
only if it was specified as an
<HPV>element type</HPV>
in the document type definition and:

<OL SPREAD="COMPACT">
<LI>it was named in the
<HPV>content model</HPV>
of the
<HPV>element declaration</HPV> for the element in which it occurred;
or</LI>
<LI>it was named in an applicable
<HPV>inclusions</HPV> exception;
or</LI>
<LI>it is the
<HPV>document type name</HPV>
and it occurred in the
<HPV>start-tag</HPV> or
<HPV>end-tag</HPV>
of the document element.</LI></OL></P>
<H3>Rank Feature</H3>
<LOSTDATA></LOSTDATA>
<P>If "RANK YES" is specified on the
<HPV>SGML declaration</HPV>,
the provisions of this sub-sub-clause apply.</P>
<H4>Full Generic Identifier</H4>
<LOSTDATA></LOSTDATA>
<P>If the full
<HPV>generic identifier</HPV> is specified
<REV REFID="AMEND1">for the start-tag of a ranked element,</REV>
its
<HPV>rank suffix</HPV> becomes the current rank
for its
<HPV>rank stem</HPV>,
and for the rank stems in any
<HPV>ranked group</HPV>
of which the
<HPV>rank stem</HPV> is a member.</P>
<H4>Rank Stem</H4>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>generic identifier specification</HPV> can be a
<HPV>rank stem</HPV>
if it was declared via a
<HPV>ranked element</HPV>
or member of a
<HPV>ranked group</HPV>
in an applicable
<HPV>element declaration</HPV>.</P>
<P>Specifying a
<HPV>rank stem</HPV> is equivalent to
specifying the
<HPV>generic identifier</HPV>
that is derived by appending the current rank to it.
It is an error to specify a
<HPV>rank stem</HPV>
if no element previously occurred
to establish the current rank for that stem.</P>
<H2>Attribute Specification List</H2>
<PROD>[31] attribute specification list =

<HPV>attribute specification</HPV>*</PROD>
<PROD>[32] attribute specification =

<HPV>s</HPV>*,
(
<HPV>name</HPV>,
<HPV>s</HPV>*,
<HPD>vi</HPD>,
<HPV>s</HPV>*)?,

<HPV>attribute value specification</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The validity of the attribute specification list is determined by
the
<HPV>attribute definition list</HPV> associated with the element.
If there is no associated
<HPV>attribute definition list</HPV>,
the
<HPV>attribute specification list</HPV> must be empty.</P>
<P>Every attribute for which there is an
<HPV>attribute definition</HPV>,
other than an impliable attribute,
must be specified
(unless markup minimization is used, as described in 7.9.1.1).</P>
<P>There can be only one
<HPV>attribute specification</HPV>
for each
<HPV>attribute definition</HPV>.</P>
<P>The leading
<HPV>s</HPV> can be omitted
from an
<HPV>attribute specification</HPV> that follows a delimiter.</P>
<H3>Minimization</H3>
<LOSTDATA></LOSTDATA>
<H4>Omitted Attribute Specification</H4>
<LOSTDATA></LOSTDATA>
<P>If "SHORTTAG YES" or "OMITTAG YES"
is specified on the
<HPV>SGML declaration</HPV>:

<OL SPREAD="COMPACT">
<LI>There need be an
<HPV>attribute specification</HPV>
only for a required attribute,
and for a current attribute on the first occurrence of any element
in whose
<HPV>attribute definition list</HPV> it appears.
Other attributes will be treated as though specified with
an
<HPV>attribute value</HPV> equal to the declared
<HPV>default value</HPV>.</LI>
<LI>If there is an
<HPV>attribute value specification</HPV>
for a current attribute,
the specified
<HPV>attribute value</HPV> will become the default value.
The new default value affects all elements associated with the

<HPV>attribute definition list</HPV> in which the attribute was defined.</LI></OL></P>
<H4>Omitted Attribute Name</H4>
<LOSTDATA></LOSTDATA>
<P>If "SHORTTAG YES" is specified on the
<HPV>SGML declaration</HPV>,
the
<HPV>name</HPV> and
<HPD>vi</HPD> can be omitted
if the
<HPV>attribute value specification</HPV>
is an undelimited
<HPV>name token</HPV> that is a member of a group
specified in the
<HPV>declared value</HPV> for that attribute.</P>
<NT>A
<HPV>name token</HPV> can occur in only one group in an

<HPV>attribute definition list</HPV> (see 11.3.3).</NT>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The normalized length of the
<HPV>attribute specification list</HPV>
is the sum of the normalized lengths of each attribute name and
attribute value specified,
which cannot exceed the "ATTSPLEN" quantity.</P>
<P>The normalized length of an attribute name is the "NORMSEP" quantity
plus the number of characters in the name.</P>
<H3>Attribute Value Specification</H3>
<PROD>[33] attribute value specification =

<HPV>attribute value</HPV> |
<HPV>attribute value literal</HPV></PROD>
<PROD>[34] attribute value literal =
(
<HPD>lit</HPD>,
<HPV>replaceable character data</HPV>*,
<HPD>lit</HPD>) |
(
<HPD>lita</HPD>,
<HPV>replaceable character data</HPV>*,
<HPD>lita</HPD>)</PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>attribute value literal</HPV> is interpreted
as an
<HPV>attribute value</HPV>
by replacing references within it,
ignoring
<HPC>Ee</HPC> and
<HPT>RS</HPT>,
and replacing an
<HPT>RE</HPT> or
<HPT>SEPCHAR</HPT> with a
<HPT>SPACE</HPT>.
<REV REFID="AMEND1">
<NT>Interpretation of an
<HPV>attribute value literal</HPV> occurs as though
the attribute were
<HPV>character data</HPV>,
regardless of its actual declared value.</NT>

<P>An attribute value other than
<HPV>character data</HPV>
is tokenized by replacing a sequence of
<HPT>SPACE</HPT> characters
with a single
<HPT>SPACE</HPT> character
and ignoring leading or trailing
<HPT>SPACE</HPT> characters.</P>
<NT>Tokenization is performed without regard to the original literal:
for example, whether CDATA or SDATA entities were used is irrelevant.</NT></REV></P>
<H4>Minimization</H4>
<REV REFID="AMEND1">
<P>An
<HPV>attribute value specification</HPV> can be an
<HPV>attribute value</HPV>
(that is, not an
<HPV>attribute value literal</HPV>)
only if it contains nothing but name characters and either:

<OL SPREAD="COMPACT">
<LI>it occurs in an
<HPV>attribute definition list</HPV>;
or</LI>
<LI>"SHORTTAG YES" is specified on the
<HPV>SGML declaration</HPV>.</LI></OL></P></REV>
<LOSTDATA></LOSTDATA>
<H3>Attribute Value</H3>
<PROD>[35] attribute value =

<HPV>character data</HPV> |

<HPV>general entity name</HPV> |

<REV REFID="AMEND1">
<HPV>general entity name list</HPV> |</REV>

<HPV>id value</HPV> |

<HPV>id reference value</HPV> |
<HPV>id reference list</HPV> |

<HPV>name</HPV> |
<HPV>name list</HPV> |

<HPV>name token</HPV> |
<HPV>name token list</HPV> |

<HPV>notation name</HPV> |

<HPV>number</HPV> |
<HPV>number list</HPV> |

<HPV>number token</HPV> |
<HPV>number token list</HPV></PROD>
<REV REFID="AMEND1">
<PROD>[35.1] general entity name list =
<HPV>name list</HPV></PROD></REV>
<PROD>[36] id value =
<HPV>name</HPV></PROD>
<PROD>[37] id reference list =
<HPV>name list</HPV></PROD>
<PROD>[38] id reference value =
<HPV>name</HPV></PROD>
<PROD>[39] name list =

<REV REFID="AMEND1">
<HPV>name</HPV>, (
<HPT>SPACE</HPT>,
<HPV>name</HPV>)*</REV></PROD>
<PROD>[40] name token list =

<REV REFID="AMEND1">
<HPV>name token</HPV>, (
<HPT>SPACE</HPT>,
<HPV>name token</HPV>)*</REV></PROD>
<PROD>[41] notation name =
<HPV>name</HPV></PROD>
<PROD>[42] number list =

<REV REFID="AMEND1">
<HPV>number</HPV>, (
<HPT>SPACE</HPT>,
<HPV>number</HPV>)*</REV></PROD>
<PROD>[43] number token list =

<REV REFID="AMEND1">
<HPV>number token</HPV>, (
<HPT>SPACE</HPT>,
<HPV>number token</HPV>)*</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>declared value</HPV> parameter of an
<HPV>attribute definition</HPV>
<REV REFID="AMEND1">determines which of the fifteen types of
<HPV>attribute value</HPV></REV>
must be specified.</P>
<H4>Syntactic Requirements</H4>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>attribute value</HPV> must conform to the
<HPV>declared value</HPV>.</P>
<P>If the
<HPV>declared value</HPV> includes a group,
the
<HPV>attribute value</HPV> must be a token in that group.</P>
<P>An empty
<HPV>attribute value literal</HPV> can be specified only
for an
<HPV>attribute value</HPV> whose type is
<HPV>character data</HPV>.</P>
<H4>Fixed Attributes</H4>
<LOSTDATA></LOSTDATA>
<P>The specified
<HPV>attribute value</HPV> for a fixed attribute
must be its
<HPV>default value</HPV>.</P>
<H4>General Entity Name</H4>
<REV REFID="AMEND1">
<P>The value of a
<HPV>general entity name</HPV> attribute,
and of each
<HPV>name</HPV> in a
<HPV>general entity name list</HPV>,
must be the
<HPV>name</HPV> of a data entity or an SGML subdocument entity.
Such a name must be declared
as though it occurred in a
<HPV>general entity reference</HPV>
with no
<HPV>name group</HPV> specified (see 9.4.4.1).</P></REV>
<LOSTDATA></LOSTDATA>
<H4>Notation</H4>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>attribute value</HPV> of a notation attribute
must be a
<HPV>notation name</HPV>
that was declared in the same document type declaration as the element.</P>
<P>It is an error to specify a value for a notation attribute
if there is an explicit content reference.</P>
<NT>As the element's
<HPV>content</HPV> will be empty,
it is pointless to specify a notation for it.
Even if the content reference were to a non-SGML data entity,
the applicable notation would be specified by
the
<HPV>notation name</HPV> parameter of the entity declaration.</NT>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The normalized length of an
<HPV>attribute value</HPV>,
whether specified directly
or interpreted from an
<HPV>attribute value literal</HPV>,
is the "NORMSEP" quantity plus:

<OL>
<LI>for a
<REV REFID="AMEND1">
<HPV>general entity name list</HPV>,</REV>

<HPV>id reference list</HPV>,

<HPV>name list</HPV>,

<HPV>name token list</HPV>,

<HPV>number list</HPV>, or

<HPV>number token list</HPV>
(even is there is only one token in the list),
the sum of the numbers of characters in each token in the list,
plus the "NORMSEP" quantity for each token in the list;
or</LI>
<LI>for all others, the number of characters in the value,
plus the "NORMSEP" quantity
for each reference to a "CDATA" or "SDATA" entity.</LI></OL></P>
<P>The normalized length of an
<HPV>attribute value</HPV>
cannot exceed the "LITLEN" quantity.</P>
<P>In a single
<HPV>start-tag</HPV>,
the total number of names
in
<HPV>id reference value</HPV>
and
<HPV>id reference list</HPV> attribute values,
whether defaulted or specified,
cannot exceed the "GRPCNT" quantity.
<REV REFID="AMEND1">
<P>In a
<HPV>single attribute specification list</HPV>,
the total number of names
in
<HPV>general entity name</HPV>
and
<HPV>general entity name list</HPV> attribute values,
whether defaulted or specified,
cannot exceed the "GRPCNT" quantity.</P></REV></P>
<H1>Processing Instruction</H1>
<PROD>[44] processing instruction =

<HPD>pio</HPD>,
<HPV>system data</HPV>,
<HPD>pic</HPD></PROD>
<PROD>[45] system data =
<HPV>character data</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Processing instructions are deprecated,
as they reduce portability of the document.
If a processing instruction must be used, it should be defined as an entity,
so that the
<HPV>system data</HPV> will be confined to the
<HPV>prolog</HPV>,
where a recipient of the document can more easily locate and modify it.</P>
<P>A
<HPV>processing instruction</HPV> that returns data
must be defined as an "SDATA" entity
and entered with an entity reference.
One that does not return data should be defined as a "PI" entity.</P>
<P>No markup is recognized in system data
other than the delimiter that would terminate it.</P>
<NT>The characters allowed in
<HPV>system data</HPV> and their interpretation
are defined by the system.
If it is desired to allow
non-SGML characters or the
<HPD>pic</HPD> delimiter character
in
<HPV>system data</HPV>,
an alternative way of entering them should be provided
so that the actual characters do not occur in the document.</NT>
<H2>Quantities</H2>
<LOSTDATA></LOSTDATA>
<P>The length of a
<HPV>processing instruction</HPV>,
exclusive of its delimiters,
cannot exceed the "PILEN" quantity.</P></H2>
<H1>Common Constructs</H1>
<LOSTDATA></LOSTDATA>
<H2>Replaceable Character Data</H2>
<PROD>[46] replaceable character data =
(
<HPV>data character</HPV> |

<HPV>character reference</HPV> |

<HPV>general entity reference</HPV> |

<HPC>Ee</HPC>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>Markup that would terminate
<HPV>replaceable character data</HPV>
is not recognized in an entity that was referenced
from within the same
<HPV>replaceable character data</HPV>.</P>
<P>An
<HPC>Ee</HPC> can occur in
<HPV>replaceable character data</HPV>
only if the reference to the entity it terminates occurred
in the same
<HPV>replaceable character data</HPV>.
<REV REFID="AMEND1">
<P>A reference to a non-SGML data entity, PI entity or SGML subdocument entity,
is prohibited in
<HPV>replaceable character data</HPV>.
A reference to a CDATA entity or SDATA entity is permitted.</P>
<NT>An effect of this sub-clause is to require that an element or marked section
that is declared to be
<HPV>replaceable character data</HPV>
must start and end in the same entity.</NT></REV></P>
<H2>Character Data</H2>
<PROD>[47] character data =
<HPV>data character</HPV>*</PROD>
<PROD>[48] data character =
<HPV>SGML character</HPV></PROD>
<PROD>[49] character =

<HPV>SGML character</HPV> |
<HPT>NONSGML</HPT></PROD>
<LOSTDATA></LOSTDATA>
<NT>A non-SGML character can be entered as a data character
within an SGML entity by using a
<HPV>character reference</HPV>.</NT>
<H3>SGML Character</H3>
<PROD>[50] SGML character =

<HPV>markup character</HPV> |
<HPT>DATACHAR</HPT></PROD>
<PROD>[51] markup character =

<HPV>name character</HPV> |
<HPV>function character</HPV> |

<HPT>DELMCHAR</HPT></PROD>
<PROD>[52] name character =

<HPV>name start character</HPV> |

<HPC>Digit</HPC> |
<HPT>LCNMCHAR</HPT> |
<HPT>UCNMCHAR</HPT></PROD>
<PROD>[53] name start character =

<HPC>LC Letter</HPC> |
<HPC>UC Letter</HPC> |

<HPT>LCNMSTRT</HPT> |
<HPT>UCNMSTRT</HPT></PROD>
<LOSTDATA></LOSTDATA>
<TABLE TYPE="TABLE4">
<TTITLE>Character Classes: Abstract Syntax</TTITLE>
<TBODY>
<ROW><C><P>Variable</P></C><C><P>Characters</P></C><C><P>Numbers</P></C><C><P>Description</P></C></ROW>
<ROW><C><P>Digit</P></C><C><P>0-9</P></C><C><P>48-57</P></C><C><P></P>Digits</C></ROW>
<ROW><C><P>Ee</P></C><C><P>(system signal; not a character)</P></C><C><P></P></C><C><P>Entity end signal</P></C></ROW>
<ROW><C><P>LC Letter</P></C><C><P>a - z</P></C><C><P>97-122</P></C><C><P>Lower-case letters</P></C></ROW>
<ROW><C><P>Special</P></C><C><P>' ( ) + , - . / : = ?</P></C><C><P>39-41 43-47 58 61 63</P></C><C><P>Special minimum data characters</P></C></ROW>
<ROW><C><P>UC Letter</P></C><C><P>A - Z</P></C><C><P>65-90</P></C><C><P>Upper-case letters</P></C></ROW>
</TBODY>
</TABLE>

<TABLE TYPE="TABLE4">
<TTITLE>Character Classes: Concrete Syntax</TTITLE>
<TBODY>
<ROW><C><P>Variable</P></C><C><P>Characters</P></C><C><P>Numbers</P></C><C><P>Description</P></C></ROW>
<ROW><C><P>DATACHAR</P></C><C><P>(implicit)</P></C><C><P>(implicit)</P></C><C><P></P>Dedicated data characters</C></ROW>
<ROW><C><P>DELMCHAR</P></C><C><P>(implicit)</P></C><C><P>(implicit)</P></C><C><P></P>Delimiter characters</C></ROW>
<ROW><C><P>FUNCHAR</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Inert function characters</P></C></ROW>
<ROW><C><P>LCNMCHAR</P></C><C><P>- .</P></C><C><P>45 46</P></C><C><P>Lower-case name characters</P></C></ROW>
<ROW><C><P>LCNMSTRT</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Lower-case name start characters</P></C></ROW>
<ROW><C><P>MSICHAR</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Markup-scan-in characters</P></C></ROW>
<ROW><C><P>MSOCHAR</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Markup-scan-out characters</P></C></ROW>
<ROW><C><P>MSSCHAR</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Markup-scan-suppress characters</P></C></ROW>
<ROW><C><P>RE</P></C><C><P></P></C><C><P>13</P></C><C><P>Record end character</P></C></ROW>
<ROW><C><P>RS</P></C><C><P></P></C><C><P>10</P></C><C><P>Record start character</P></C></ROW>
<ROW><C><P>SEPCHAR</P></C><C><P></P></C><C><P>9</P></C><C><P>Separator characters</P></C></ROW>
<ROW><C><P>SPACE</P></C><C><P></P></C><C><P>32</P></C><C><P>Space character</P></C></ROW>
<ROW><C><P>UCNMCHAR</P></C><C><P>- .</P></C><C><P>45 46</P></C><C><P>Upper-case name characters</P></C></ROW>
<ROW><C><P>UCNMSTRT</P></C><C><P>(none)</P></C><C><P>(none)</P></C><C><P>Upper-case name start characters</P></C></ROW>
</TBODY>
</TABLE>

<H3>Function Character</H3>
<PROD>[54] function character =

<HPT>RE</HPT> |
<HPT>RS</HPT> |
<HPT>SPACE</HPT> |
<HPT>SEPCHAR</HPT> |

<HPT>MSOCHAR</HPT> |
<HPT>MSICHAR</HPT> |
<HPT>MSSCHAR</HPT> |

<HPT>FUNCHAR</HPT></PROD>
<LOSTDATA></LOSTDATA>
<H2>Name</H2>
<PROD>[55] name =

<HPV>name start character</HPV>,
<HPV>name character</HPV>*</PROD>
<PROD>[56] number =
<HPC>Digit</HPC>+</PROD>
<PROD>[57] name token =
<HPV>name character</HPV>+</PROD>
<PROD>[58] number token =

<HPC>Digit</HPC>,
<HPV>name character</HPV>*</PROD>
<LOSTDATA></LOSTDATA>
<P>The upper case form of each character in a
<HPV>name</HPV>,

<HPV>name token</HPV>,
<HPV>number</HPV>, or
<HPV>number token</HPV>,
as specified by the "NAMECASE" parameter
of the
<HPV>SGML declaration</HPV>,
is substituted for the character actually entered.
<REV REFID="AMEND1">
<NT>A
<HPV>number</HPV> or
<HPV>number token</HPV> is not a quantity
but a character string, like a
<HPV>name</HPV> or a
<HPV>name token</HPV>:
therefore,
<Q>01</Q> and
<Q>1</Q>, for example, are not equivalent.</NT></REV></P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The length of a
<HPV>name</HPV>,
<HPV>name token</HPV>,

<HPV>number</HPV>, or
<HPV>number token</HPV>,
cannot exceed the "NAMELEN" quantity.</P>
<H2>Entity References</H2>
<LOSTDATA></LOSTDATA>
<P>The replacement text of an entity reference must comply with the syntactic
and semantic requirements that govern the context of the reference.
For purposes of this rule, a reference to
an
<HPV>SGML subdocument entity</HPV> or a
<HPV>non-SGML data entity</HPV>
is treated like a reference to a
<HPV>data character</HPV>.</P>
<NT>Such entities can also be accessed by a

<HPV>general entity name attribute</HPV>.</NT>
<P>A reference to an undeclared entity is an error
unless there is an applicable default entity (see 9.4.4).</P>
<P>A reference to an entity that has already been referenced
and has not yet ended is invalid
(i.e., entities cannot be referenced recursively).</P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The number of open entities
(except for the unreferenced
<HPV>SGML document entity</HPV>
in which the document begins)
cannot exceed the "ENTLVL" quantity.</P>
<H3>Limits</H3>
<LOSTDATA></LOSTDATA>
<P>The number of open SGML subdocument entities
cannot exceed the quantity specified on the "SUBDOC" parameter
of the
<HPV>SGML declaration</HPV>.</P>
<H3>Obfuscatory Entity References</H3>
<LOSTDATA></LOSTDATA>
<P>Any use of entity references that obscures the markup is deprecated.</P>
<NT>Most such abuses are prohibited by the syntax of SGML.
The following principles should be observed
(those that say
<Q>must</Q> are restatements of syntax rules,
stated formally elsewhere, that enforce the principles):

<OL>
<LI>The opening delimiter of a tag,
<HPV>processing instruction</HPV>,
declaration, literal, or other delimited text, must be in the
same entity as the closing delimiter.
An entity must not end in delimited text unless it began there,
and an entity that begins there must end there.</LI>
<LI>The content of an element or marked section that was declared to be

<HPV>character data</HPV> or
<HPV>replaceable character data</HPV>,
<REV REFID="AMEND1">or of a marked section that is ignored,
must (and the content of other elements and marked sections should)</REV>
start and end in the same entity.</LI>
<LI>
<REV REFID="AMEND1">For other elements and marked sections,
the
<HPV>start-tag</HPV> and
<HPV>end-tag</HPV>
(or
<HPV>marked section start</HPV> and
<HPV>marked section end</HPV>)</REV>should be in in the same entity,
or they should be the replacement text of entities
whose references are in the same entity.</LI>
<LI>In a markup declaration, a reference must be replaced
either by zero or more consecutive complete parameters
(with any intervening
<HPV>ps</HPV> separators),
or, within a group, by one or more consecutive complete tokens
(with any intervening
<HPV>ts</HPV> separators and/or connectors).</LI></OL></NT>
<H3>Named Entity Reference</H3>
<PROD>[59] general entity reference =

<HPD>ero</HPD>,

<REV REFID="AMEND1">
<HPV>name group</HPV>?,
<HPV>name</HPV>,</REV>

<HPV>reference end</HPV></PROD>
<PROD>[60] parameter entity reference =

<HPD>pero</HPD>,

<REV REFID="AMEND1">
<HPV>name group</HPV>?,
<HPV>name</HPV>,</REV>

<HPV>reference end</HPV></PROD>
<REV REFID="AMEND1">
<P>A
<HPV>name group</HPV> can be specified only if "CONCUR YES",
"SIMPLE YES", "IMPLICIT YES", or "EXPLICIT YES"
is specified on the
<HPV>SGML declaration</HPV>,
and the reference does not occur
within a
<HPV>start-tag</HPV> or
<HPV>prolog</HPV>.</P>
<NT>This requirement does not prohibit specifying a
<HPV>name group</HPV>
for a
<HPV>parameter entity reference</HPV> within a

<HPV>marked section start</HPV> in a document instance.</NT>

<P>If a
<HPV>name group</HPV> is specified,
the entity reference is ignored
unless a
<HPV>name</HPV> in the
<HPV>name group</HPV>
is that of an active document type or link type.</P>
<H4>Applicable Entity Declaration</H4>
<LOSTDATA></LOSTDATA>
<NT>The following requirements apply to entity names used in the value of
general entity name and general entity name list attributes,
as well as to named entity references.</NT>
<P>Before an
<HPV>entity name</HPV> can be used,
it must be declared by an
<HPV>entity declaration</HPV> in all applicable DTDs,
except that a general entity
<HPV>name</HPV>
that is undeclared in a particular DTD
is treated as though it had been declared for the default entity
if that DTD has one.</P>
<P>The applicable DTDs depend on the context in which
the entity
<HPV>name</HPV> occurs, as follows:

<OL SPREAD="COMPACT">
<LI>Within a start-tag, all DTDs applicable to the tag.

<NT>That is, either the base DTD or those of active document types
named in the tag's
<HPV>document type specification</HPV>.</NT></LI>
<LI>Elsewhere in a document instance,
the DTDs of active document types
or the source DTDs of active link types
specified in a named entity reference's
<HPV>name group</HPV>,
or, for any name that is undeclared in such a DTD,
or if no
<HPV>name group</HPV> is specified, the base DTD.

<NT>An effect of this requirement is that an entity
declared in the base document type
can be referenced in an instance of any document type
in which no entity with the same name was defined,
and in which, for a general entity, no default entity was defined.</NT></LI>
<LI>Within a DTD, the same DTD.</LI>
<LI>Within a
<HPV>result attribute specification</HPV>, the result DTD.</LI>
<LI>Elsewhere in an LPD, the source DTD.

<NT>An LPD is parsed as though entity declarations within it
had occurred in its source DTD.</NT></LI></OL></P>
<NT>
<OL>
<LI>An effect of these requirements is that a default entity
declared in the base document type
will be referenced by an undeclared general entity name
in an instance of any document type
that does not itself have a default entity.</LI>
<LI>If an entity declaration specifies a data content notation,
the notation must be declared in the same DTD as the entity.</LI></OL></NT></H4></REV>
<LOSTDATA></LOSTDATA>
<H3>Reference End</H3>
<PROD>[61] reference end = (
<HPD>refc</HPD> |
<HPT>RE</HPT>)?</PROD>
<LOSTDATA></LOSTDATA>
<NT>Ending a reference with an
<HPT>RE</HPT>
has the effect of suppressing the record end.</NT>
<P>The
<HPD>refc</HPD> or
<HPT>RE</HPT> can be omitted
only if the reference is not followed
<REV REFID="AMEND1">by a character that could occur in the reference,</REV>
or by a character that could be interpreted
as the omitted
<HPV>reference end</HPV>.</P>
<H3>Short Reference</H3>
<LOSTDATA></LOSTDATA>
<P>If a
<HPV>short reference</HPV> is mapped to
a general entity name in the current map,
it is treated as markup and replaced by the named entity.
If the
<HPV>short reference</HPV> is mapped to nothing,
each character in the delimiter string is treated
as an
<HPV>s</HPV> separator if it can be recognized as such,
and if not it is treated as data.</P>
<H4>Equivalent Reference String</H4>
<LOSTDATA></LOSTDATA>
<P>A short reference can be removed from a document
by replacing it with an equivalent reference string
that contains a named entity reference.
The entity
<HPV>name</HPV> must be that to which
the
<HPV>short reference</HPV> is mapped in the current map.</P>
<P>If the short reference contains any quantity
of
<HPT>RS</HPT> or
<HPT>RE</HPT> characters,
the equivalent reference string
will include a single
<HPT>RS</HPT> or
<HPT>RE</HPT>, or both,
as shown in the following list:

<LINES KEEP="ALL"> Short Reference
<HPV>Equivalent Reference String</HPV>
 No
<HPT>RS</HPT> or
<HPT>RE</HPT>
<HPD>ero</HPD>,
<HPV>name</HPV>,
<HPD>refc</HPD>

<HPT>RS</HPT>; no
<HPT>RE</HPT>
<HPT>RS</HPT>,
<HPD>ero</HPD>,
<HPV>name</HPV>,
<HPD>refc</HPD>

<HPT>RE</HPT>; no
<HPT>RS</HPT>
<HPD>ero</HPD>,
<HPV>name</HPV>,
<HPT>RE</HPT>
 Both
<HPT>RS</HPT> and
<HPT>RE</HPT>
<HPT>RS</HPT>,
<HPD>ero</HPD>,
<HPV>name</HPV>,
<HPT>RE</HPT></LINES>

<NOTEL>
<LI>Equivalent reference strings are used when a document is converted
from a concrete syntax that supports short references to one that does not.</LI>
<LI>A single
<HPT>RS</HPT> and/or
<HPT>RE</HPT> is preserved
in the equivalent reference string
to prevent records from becoming joined,
and possibly exceeding a system's maximum length restriction.
They are not recognized as data:
the
<HPT>RS</HPT> because it never is,
and the
<HPT>RE</HPT> because it serves as the
<HPV>reference end</HPV>.</LI></NOTEL></P>
<H2>Character Reference</H2>
<PROD>[62] character reference =

<HPD>cro</HPD>,
(
<HPV>function name</HPV> |
<HPV>character number</HPV>),

<HPV>reference end</HPV></PROD>
<PROD>[63] function name =
"RE" | "RS" | "SPACE" |
<HPV>name</HPV></PROD>
<PROD>[64] character number =
<HPV>number</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>name</HPV> specified as a
<HPV>function name</HPV>
must have been specified as an
<HPV>added function</HPV>
in the concrete syntax.</P>
<P>A
<HPV>character reference</HPV> should be used
when a character could not otherwise be entered conveniently in the text.</P>
<P>A replacement character is considered to be in the same entity as its reference.</P>
<P>A replacement character is treated as though it were entered directly
except that the replacement for a numeric
<HPV>character reference</HPV>
is always treated as data
<REV REFID="AMEND1">in the context in which the replacement occurs.</REV>

<NOTEL>
<LI>A system can determine its own internal representation
for a replacement character.
Care should be taken to distinguish a normal
<HPV>function character</HPV>
(entered directly or as a replacement for a named character reference)
from one that replaces a numeric character reference.</LI>
<LI>When a document is translated to a different document character set,
the
<HPV>character number</HPV> of each numeric character reference
must be changed to the corresponding
<HPV>character number</HPV> of the new set.</LI></NOTEL></P>

<TABLE TYPE="TABLE6">
<TTITLE>Reference Delimiter Set: General</TTITLE>
<TBODY>
<ROW><C><P>Name</P></C><C><P>String</P></C><C><P>Number</P></C><C><P>Mode</P></C><C><P>Constraint</P></C><C><P>Description of role</P></C></ROW>
<ROW><C><P>And</P></C><C><P>&amp;</P></C><C><P>38</P></C><C><P>GPR</P></C><C><P></P></C><C><P>And connector</P></C></ROW>
<ROW><C><P>COM</P></C><C><P>--</P></C><C><P>45 45</P></C><C><P>CXT MD</P></C><C><P></P></C><C><P>Comment start or end</P></C></ROW>
<ROW><C><P>CRO</P></C><C><P>&amp;#</P></C><C><P>38 35</P></C><C><P>CON LIT</P></C><C><P>CREF</P></C><C><P>Character reference open</P></C></ROW>
<ROW><REV REFID="AMEND1">
<C><P>DSC</P></C><C><P>]</P></C><C><P>93</P></C><C><P>DS MD</P></C><C><P>ENT</P></C><C><P>Declaration subset close</P></C>
</REV>
</ROW>
<ROW><C><P>DSO</P></C><C><P>[</P></C><C><P>91</P></C><C><P>CXT MD</P></C><C><P></P></C><C><P>Declaration subset open</P></C></ROW>
<ROW><C><P>DTGC</P></C><C><P>[</P></C><C><P>93</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Data tag group close</P></C></ROW>
<ROW><C><P>DTGO</P></C><C><P>[</P></C><C><P>91</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Data tag group open</P></C></ROW>
<ROW><C><P>ERO</P></C><C><P>&amp;</P></C><C><P>38</P></C><C><P>CON LIT</P></C><C><P>NMS</P></C><C><P>Entity reference open</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>ETAGO</P></C><C><P>&lt;/</P></C><C><P>60 47</P></C><C><P>CON TAG</P></C><C><P>GI</P></C><C><P>End-tag open</P></C>
</REV>
</ROW>
<ROW><C><P>GRPC</P></C><C><P>)</P></C><C><P>41</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Group close</P></C></ROW>
<ROW><C><P>GRPO</P></C><C><P>(</P></C><C><P>40</P></C><C><P>CXT GRP MD</P></C><C><P></P></C><C><P>Group open</P></C></ROW>
<ROW><C><P>LIT</P></C><C><P>"</P></C><C><P>34</P></C><C><P>GRP LIT MD TAG</P></C><C><P></P></C><C><P>Literal start or end</P></C></ROW>
<ROW><C><P>LITA</P></C><C><P>'</P></C><C><P>39</P></C><C><P>GRP LIT MD TAG</P></C><C><P></P></C><C><P>Literal start or end (alternative)</P></C></ROW>
<ROW><C><P>MDC</P></C><C><P>></P></C><C><P>62</P></C><C><P>CXT MD</P></C><C><P></P></C><C><P>Markup declaration close</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>MDO</P></C><C><P>&lt;!</P></C><C><P>60 33</P></C><C><P>CON DSM</P></C><C><P></P></C><C><P>Markup declaration open</P></C>
</REV>
</ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>MINUS</P></C><C><P>-</P></C><C><P>45</P></C><C><P>MD</P></C><C><P>EX</P></C><C><P>Exclusion</P></C>
</REV>
</ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>MSC</P></C><C><P>]]</P></C><C><P>93 93</P></C><C><P>CON DSM</P></C><C><P>MSE</P></C><C><P>Marked section close</P></C>
</REV>
</ROW>
<ROW><C><P>NET</P></C><C><P>/</P></C><C><P>47</P></C><C><P>CON TAG</P></C><C><P>ELEM</P></C><C><P>Null end-tag</P></C></ROW>
<ROW><C><P>OPT</P></C><C><P>?</P></C><C><P>63</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Optional occurrence indicator</P></C></ROW>
<ROW><C><P>OR</P></C><C><P>|</P></C><C><P>12</P></C><C><P>GRP</P></C><C><P>EX</P></C><C><P>Or connector</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>PERO</P></C><C><P>%</P></C><C><P>37</P></C><C><P>DSM GRP MD LIT</P></C><C><P>NMS</P></C><C><P>Parameter entity reference open</P></C>
</REV>
</ROW>
<ROW><C><P>PIC</P></C><C><P>&gt;</P></C><C><P>62</P></C><C><P>PI</P></C><C><P></P></C><C><P>Processing instruction close</P></C></ROW>
<ROW><C><P>PIO</P></C><C><P>&lt;?</P></C><C><P>60 63</P></C><C><P>CON DSM</P></C><C><P></P></C><C><P>Processing instruction open</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>PLUS</P></C><C><P>+</P></C><C><P>43</P></C><C><P>GRP MD</P></C><C><P>EX</P></C><C><P>Required and repeatable; inclusion</P></C>
</REV>
</ROW>
<ROW><C><P>REFC</P></C><C><P>;</P></C><C><P>59</P></C><C><P>REF</P></C><C><P></P></C><C><P>Reference close</P></C></ROW>
<ROW><C><P>REP</P></C><C><P>*</P></C><C><P>42</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Optional and repeatable</P></C></ROW>
<ROW><C><P>RNI</P></C><C><P>#</P></C><C><P>35</P></C><C><P>GRP MD</P></C><C><P></P></C><C><P>Reserved name indicator</P></C></ROW>
<ROW><C><P>SEQ</P></C><C><P>,</P></C><C><P>44</P></C><C><P>GRP</P></C><C><P></P></C><C><P>Sequence connector</P></C></ROW>
<ROW><C><P>SHORTREF</P></C><C><P></P></C><C><P>45</P></C><C><P>CON</P></C><C><P></P></C><C><P>Short reference (see figure 4)</P></C></ROW>
<ROW><C><P>STAGO</P></C><C><P>&lt;</P></C><C><P>60</P></C><C><P>CON TAG</P></C><C><P>GI</P></C><C><P>Start-tag open</P></C></ROW>
<ROW><C><P>TAGC</P></C><C><P>&gt;</P></C><C><P>62</P></C><C><P>CXT TAG</P></C><C><P></P></C><C><P>Tag close</P></C></ROW>
<ROW><C><P>VI</P></C><C><P>=</P></C><C><P>61</P></C><C><P>TAG</P></C><C><P></P></C><C><P>Value indicator</P></C></ROW>
</TBODY>
</TABLE>

<TABLE TYPE="TABLE3">
<TTITLE>Reference Delimiter Set: Short References</TTITLE>
<TBODY>
<ROW><C><P>String</P></C><C><P>Number</P></C><C><P>Description</P></C></ROW>
<ROW><C><P>&amp;#TAB;</P></C><C><P>9</P></C><C><P>Horizontal tab</P></C></ROW>
<ROW><C><P>&amp;#RE;</P></C><C><P>13</P></C><C><P>Record end</P></C></ROW>
<ROW><C><P>&amp;#RS;</P></C><C><P>10</P></C><C><P>Record start</P></C></ROW>
<ROW><C><P>&amp;#RS;B</P></C><C><P>10 66</P></C><C><P>Leading blanks</P></C></ROW>
<ROW><C><P>&amp;#RS;&amp;#RE;</P></C><C><P>10 13</P></C><C><P>Empty record</P></C></ROW>
<ROW><C><P>&amp;#RS;B;&amp;#RE;</P></C><C><P>10 66 13</P></C><C><P>Blank record</P></C></ROW>
<ROW><C><P>B&amp;#RE;</P></C><C><P>66 13</P></C><C><P>Trailing blanks</P></C></ROW>
<ROW><C><P>&amp;#SPACE;</P></C><C><P>32</P></C><C><P>Space</P></C></ROW>
<ROW><C><P>BB</P></C><C><P>66 66</P></C><C><P>Two or more blanks</P></C></ROW>
<ROW><C><P>"</P></C><C><P>34</P></C><C><P>Quotation mark</P></C></ROW>
<ROW><C><P>#</P></C><C><P>35</P></C><C><P>Number sign</P></C></ROW>
<ROW><C><P>%</P></C><C><P>37</P></C><C><P>Percent sign</P></C></ROW>
<ROW><C><P>'</P></C><C><P>39</P></C><C><P>Apostrophe</P></C></ROW>
<ROW><C><P>(</P></C><C><P>40</P></C><C><P>Left parenthesis</P></C></ROW>
<ROW><C><P>)</P></C><C><P>41</P></C><C><P>Right parenthesis</P></C></ROW>
<ROW><C><P>*</P></C><C><P>42</P></C><C><P>Asterisk</P></C></ROW>
<ROW><C><P>+</P></C><C><P>43</P></C><C><P>Plus sign</P></C></ROW>
<ROW><C><P>,</P></C><C><P>44</P></C><C><P>Comma</P></C></ROW>
<ROW><C><P>-</P></C><C><P>45</P></C><C><P>Hyphen</P></C></ROW>
<ROW><C><P>--</P></C><C><P>45 45</P></C><C><P>Two hyphens</P></C></ROW>
<ROW><C><P>:</P></C><C><P>58</P></C><C><P>Colon</P></C></ROW>
<ROW><C><P>;</P></C><C><P>59</P></C><C><P>Semicolon</P></C></ROW>
<ROW><C><P>=</P></C><C><P>61</P></C><C><P>Equals sign</P></C></ROW>
<ROW><C><P>@</P></C><C><P>64</P></C><C><P>Commercial at</P></C></ROW>
<ROW><C><P>[</P></C><C><P>91</P></C><C><P>Left square bracket</P></C></ROW>
<ROW><C><P>]</P></C><C><P>93</P></C><C><P>Right square bracket</P></C></ROW>
<ROW><C><P>^</P></C><C><P>94</P></C><C><P>Circumflex accent</P></C></ROW>
<ROW><C><P>_</P></C><C><P>95</P></C><C><P>Low line</P></C></ROW>
<ROW><C><P>{</P></C><C><P>123</P></C><C><P>Left curly bracket</P></C></ROW>
<ROW><C><P>|</P></C><C><P>124</P></C><C><P>Vertical line</P></C></ROW>
<ROW><C><P>}</P></C><C><P>125</P></C><C><P>Right curly bracket</P></C></ROW>
<ROW><C><P>~</P></C><C><P>126</P></C><C><P>Tilde</P></C></ROW>
</TBODY>
</TABLE>

<H2>Delimiter Recognition</H2>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">Except as otherwise provided in this International Standard,</REV>a delimiter string is recognized as satisfying a delimiter role
only within the particular recognition mode (or modes)
in which the role is meaningful
and, in some cases, only if a contextual constraint is satisfied.
The roles, their recognition modes,
and any contextual constraints on their recognition,
are listed in figure 3.
Also shown are
the strings assigned to general delimiters in the reference delimiter set,
and the character number of those strings in the
<REV REFID="AMEND1">
<HPV>syntax-reference character set</HPV> of the reference concrete syntax.</REV>
The strings assigned as short reference delimiters
in the reference delimiter set are shown in figure 4.
<REV REFID="AMEND1">
<NT>A named character reference can be used to enter the first character
of a delimiter string or delimiter-in-context, but only the first character.</NT>

<P>All characters of a delimiter string or delimiter-in-context (see 9.6.2)
must occur in the same entity.</P></REV></P>
<H3>Recognition Modes</H3>
<LOSTDATA></LOSTDATA>
<P>The recognition modes are:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="6">
<DT>Mode</DT>
<DD>
<STRONG>Meaning</STRONG></DD>
<DT>CON</DT>
<DD>Recognized in
<HPV>content</HPV> and
in the
<HPV>marked section</HPV> of marked section declarations
that occur in
<HPV>content</HPV>.
<REV REFID="AMEND1">
<NT>Most delimiters will not be recognized when the
<HPV>content</HPV> is

<HPV>character data</HPV> or
<HPV>replaceable character data</HPV>.</NT></REV></DD>
<DT>CXT</DT>
<DD>Recognized as part of the contextual sequence of
<REV REFID="AMEND1">a
<Q>CON</Q> or
<Q>DSM</Q> mode delimiter-in-context.</REV>
(See below.)
<REV REFID="AMEND1">
<DT>DS</DT>
<DD>Recognized in a declaration subset.</DD>
<DT>DSM</DT>
<DD>Recognized in a declaration subset or
in the
<HPV>marked section</HPV> of marked section declarations
that occur in a declaration subset.</DD></REV></DD>
<DT>GRP</DT>
<DD>Recognized in a group.</DD>
<DT>LIT</DT>
<DD>Recognized in a literal.</DD>
<DT>MD</DT>
<DD>
<REV REFID="AMEND1">Recognized in a
<HPV>markup declaration</HPV>.</REV></DD>
<DT>PI</DT>
<DD>Recognized in a
<HPV>processing instruction</HPV>.</DD>
<DT>REF</DT>
<DD>Recognized in a

<HPV>general entity reference</HPV>,

<HPV>parameter entity reference</HPV>, or

<HPV>character reference</HPV>.</DD>
<DT>TAG</DT>
<DD>Recognized in a
<HPV>start-tag</HPV> or
<HPV>end-tag</HPV>.</DD></DL>
<REV REFID="AMEND1">
<NT>Recognition modes can nest.
For example,
when a markup declaration begins, the recognition mode becomes
<Q>MD</Q>.
If a
<HPD>grpo</HPD> occurs in the declaration, the mode will become
<Q>GRP</Q>,
and an
<HPD>mdc</HPD> (for example) will not be recognizable.
When a
<HPD>grpc</HPD> occurs, the
<Q>GRP</Q> mode ends and
the recognition mode again becomes
<Q>MD</Q>.</NT></REV></P>
<H3>Contextual Constraints</H3>
<LOSTDATA></LOSTDATA>
<P>The most common constraint is that the delimiter string must start
a delimiter-in-context in which it is followed by one of the
listed contextual sequences:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="6">
<DT>CREF</DT>
<DD>
<HPV>name start character</HPV> or
<HPC>Digit</HPC></DD>
<DT>DCL</DT>
<DD>
<HPV>name start character</HPV>,

<HPD>com</HPD>,
<HPD>dso</HPD>, or
<HPD>mdc</HPD></DD>
<DT>GI</DT>
<DD>
<HPV>name start character</HPV>,
or, if "SHORTTAG YES" is specified on the
<HPV>SGML declaration</HPV>,

<HPD>tagc</HPD>,
or, if "CONCUR YES" is specified on the
<HPV>SGML declaration</HPV>,

<HPD>grpo</HPD></DD>
<DT>MSE</DT>
<DD>
<HPD>mdc</HPD></DD>
<DT>NMS</DT>
<DD>
<HPV>name start character</HPV>,
<REV REFID="AMEND1">or, if "CONCUR YES", "SIMPLE YES",
"IMPLICIT YES", or "EXPLICIT YES",</REV>
is specified on the
<HPV>SGML declaration</HPV>,

<HPD>grpo</HPD></DD></DL></P>
<P>
<REV REFID="AMEND1">Other contextual constraints are:</REV>
<DL SPREAD="COMPACT" TERMHI="2" TSIZE="6">
<DT>ELEM</DT>
<DD>In
<Q>CON</Q> mode, recognized only within an element whose

<HPV>start-tag</HPV> was a
<HPV>net-enabling start-tag</HPV>;
in
<Q>TAG</Q> mode, no constraints.
<REV REFID="AMEND1">
<DT>EX</DT>
<DD>In
<Q>MD</Q> mode, recognized only at the start of a delimiter-in-context
in which it is followed by
<HPD>grpo</HPD>;
in
<Q>GRP</Q> mode, no constraints.</DD>
<DT>ENT</DT>
<DD>Recognized only in the same entity as the corresponding
<HPD>dso</HPD>.</DD></REV></DD></DL></P>
<H3>Order of Recognition</H3>
<LOSTDATA></LOSTDATA>
<P>Delimiter strings (including any required contextual sequences)
are recognized in the order they occur, with no overlap.</P>
<NT>For example, if
<Q>abc</Q> and
<Q>bcd</Q> are delimiter strings,
and the document contains
<Q>abcde</Q>,
then
<Q>abc</Q> will be recognized and parsing will continue at
<Q>d</Q>,
so
<Q>bcd</Q> will not be recognized.</NT>
<P>This rule holds true even if the recognized delimiter is semantically incorrect,
or is a short reference that is mapped to nothing.</P>
<NT>For example, in the reference delimiter set,
the solidus (/) will be recognized as part of an
<HPD>etago</HPD>
delimiter-in-context rather than as a
<HPD>net</HPD>,
even if the
<HPV>end-tag</HPV> GI was not declared,
or is not the GI of an open element.</NT>
<H3>Delimiters Starting with the Same Character</H3>
<LOSTDATA></LOSTDATA>
<P>If multiple delimiter strings start with the same character,
only the longest delimiter string or delimiter-in-context among them
will be recognized at a given point in the document.</P>
<NT>For example, if
<Q>ab</Q> and
<Q>abc</Q> are delimiters
and the document contains
<Q>abcd</Q>,
then
<Q>abc</Q> will be recognized and parsing will continue at
<Q>d</Q>,
so
<Q>ab</Q> will not be recognized.</NT>
<P>This rule holds true even if the longer delimiter is semantically incorrect,
or is a short reference that is mapped to nothing.</P>
<NT>If, in the previous example,
<Q>ab</Q> and
<Q>abc</Q> were
short reference delimiters,
short reference
<Q>abc</Q> alone would be recognized
and short reference
<Q>ab</Q> would not be,
even if short reference
<Q>abc</Q> were mapped to nothing in the current map
and short reference
<Q>ab</Q> were mapped to an entity.</NT>
<H3>Short References with Blank Sequences</H3>
<LOSTDATA></LOSTDATA>
<P>If there is a B sequence in the definition of a short reference delimiter,
it will cause recognition of a blank sequence in the
<HPV>content</HPV>.
The minimum length of the blank sequence is the length of the B sequence.</P>
<NT>That is, one B means one or more blanks, two B's means two or more blanks, etc.</NT>
<P>A string that could be recognized as more than one delimiter
will be considered the string of the most specific delimiter that it satisfies.</P>
<NT>For example, a tab character would be recognized as
<Q>&amp;#TAB;</Q>
in preference to
<Q>B</Q>,
and three spaces would be recognized as
<Q>BBB</Q> in preference to
<Q>BB</Q>.</NT>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of a blank sequence recognized as a short reference
cannot exceed the "BSEQLEN" quantity.
If an actual blank sequence is longer,
only the first "BSEQLEN" characters will be included
in the short reference string,
and parsing will resume with the following character.</P>
<H3>Name Characters</H3>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">If a
<HPV>name character</HPV> is assigned to a delimiter role,</REV>it will be recognized as a delimiter
(in preference to recognition as a
<HPV>name character</HPV>)
if a
<HPV>name token</HPV> has not already begun;
if found within a
<HPV>name token</HPV>,
it will be treated as a
<HPV>name character</HPV>.</P>
<P>If general upper-case substitution is specified by the
"NAMECASE" parameter of the
<HPV>SGML declaration</HPV>,
then for purposes of delimiter recognition,
a
<HPV>name character</HPV> assigned to a delimiter role
is treated as though it were its upper-case form.</P>
<H2>Markup Suppression</H2>
<LOSTDATA></LOSTDATA>
<P>An
<HPT>MSOCHAR</HPT> suppresses recognition of markup
until an
<HPT>MSICHAR</HPT> or entity end occurs.
An
<HPT>MSSCHAR</HPT> does so for the next character in the same entity
(if any).</P>
<NT>An
<HPT>MSOCHAR</HPT> occurring in
<HPV>character data</HPV>
or other delimited text
will therefore suppress recognition of the closing delimiter.
An
<HPT>MSSCHAR</HPT> could do so if it preceded the delimiter.</NT>
<P>If markup recognition has not been suppressed by an
<HPT>MSOCHAR</HPT>,
an
<HPT>MSICHAR</HPT>
has no effect on markup recognition, but is not an error.</P>
<P>If markup recognition has been suppressed by an
<HPT>MSOCHAR</HPT>,
a subsequent
<HPT>MSOCHAR</HPT> or
<HPT>MSSCHAR</HPT>
has no effect on markup recognition, but is not an error.</P>
<P>An
<HPT>MSOCHAR</HPT> that follows an
<HPT>MSSCHAR</HPT>
has no effect on markup recognition.</P>
<H2>Capacity</H2>
<LOSTDATA></LOSTDATA>
<P>The size and complexity of a document must not exceed
the number of capacity points allowed by the document capacity set
for the objects occurring in the document.</P>
<P>The names of the total and individual capacities,
together with the values assigned to them in the reference capacity set,
are shown in figure 5.
The set's public identifier is:

<XMP>ISO 8879-1986//CAPACITY Reference//EN</XMP></P>
<P>The points accumulated for each type of object
cannot exceed the value of that object's individual capacity,
and the total points for all objects cannot exceed
the "TOTALCAP" value.</P>
<P>The capacity values must be sufficient for the greatest capacity requirement
among the possible sets of concurrent instances
or chains of link processes that could be processed at once.</P>
<P>Points are counted for the SGML document entity
and SGML text entities referenced from it,
plus the set of possible open subdocument entities
and SGML text entities referenced from them
that would require the largest capacity.</P>
<NT>As an example of capacity calculation,
when a concrete syntax with 32 short references
and a "NAMELEN" of 8 is used,
a capacity of 30818 or more would be required to accommodate a document with
100 entities averaging 70 characters (800+7000),
200 element types (1600)
with 2000 tokens in content models (16000)
and 25 exceptions group with a total of 50 names (200+400),
50 attributes with default values averaging 20 characters (400+1000)
and 100 attribute names tokens (800),
5 data content notations with identifiers averaging 50 characters (40+250),
50 ID and 50 IDREF attributes (400+400),
5 short reference maps (5x(8+(8x32))=1320),
and a single implicit link declaration with 4 link sets,
each containing 5 source element names (40+168).</NT>
<H1>Markup Declarations: General</H1>
<LOSTDATA></LOSTDATA>
<NT>The declaration names and keywords in the syntax productions
are reference reserved names
that can be redefined for a variant concrete syntax
with the
<HPV>reserved name use</HPV> parameter
of the
<HPV>SGML declaration</HPV>.</NT>
<H2>Parts of Declarations</H2>
<LOSTDATA></LOSTDATA>
<H3>Parameter Separator</H3>
<PROD>[65] ps =

<HPV>s</HPV> |
<HPC>Ee</HPC> |
<HPV>parameter entity reference</HPV> |

<HPV>comment</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>parameter entity reference</HPV> can be used
wherever a parameter could occur.
The entity must consist of zero or more of the consecutive complete parameters
that follow the
<HPV>ps</HPV> in which the reference occurs,
<REV REFID="AMEND1">together with any surrounding or intervening
<HPV>ps</HPV> separators.</REV>
The entity must end within the same declaration.</P>
<P>An
<HPC>Ee</HPC> can occur in a
<HPV>ps</HPV>
only if the reference to the entity it terminates
occurs in a
<HPV>ps</HPV> in the same declaration.</P>
<P>A required
<HPV>ps</HPV> that is adjacent
to a delimiter or another
<HPV>ps</HPV>
can be omitted if no ambiguity would be created thereby.</P>
<P>A
<HPV>ps</HPV> must begin with an
<HPV>s</HPV>
if omitting it would create an ambiguity.</P>
<H3>Parameter Literal</H3>
<PROD>[66] parameter literal =
(
<HPD>lit</HPD>,
<HPV>replaceable parameter data</HPV>,
<HPD>lit</HPD>) |
(
<HPD>lita</HPD>,
<HPV>replaceable parameter data</HPV>,
<HPD>lita</HPD>)</PROD>
<PROD>[67] replaceable parameter data =
(
<HPV>data character</HPV> |
<HPV>character reference</HPV> |

<HPV>parameter entity reference</HPV> |
<HPC>Ee</HPC>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>parameter literal</HPV> is interpreted as a parameter (or token)
by replacing references while the declaration is being processed.</P>
<P>Except for parameter entity and character references,
no markup is recognized in a
<HPV>parameter literal</HPV>
other than the terminal
<HPD>lit</HPD> or
<HPD>lita</HPD>,
and those are not recognized within the replacement text of a reference.</P>
<NT>If the literal is in the
<HPV>entity text</HPV> parameter
of an
<HPV>entity declaration</HPV>,
markup characters in its text could be recognized
when the entity is referenced.</NT>
<P>An
<HPC>Ee</HPC> can occur in
<HPV>replaceable parameter data</HPV>
only if the reference to the entity it terminates
occurred in the same
<HPV>replaceable parameter data</HPV>.</P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of an interpreted
<HPV>parameter literal</HPV> cannot exceed
the "LITLEN" quantity
(unless some other restriction is applied in the context in which it is used).</P>
<H3>Group</H3>
<PROD>[68] name token group =

<HPD>grpo</HPD>,

<HPV>ts</HPV>*,
<HPV>name token</HPV>,
(
<HPV>ts</HPV>*,
<HPV>connector</HPV>,
<HPV>ts</HPV>*,
<HPV>name token</HPV>)*,

<HPV>ts</HPV>*,
<HPD>grpc</HPD></PROD>
<PROD>[69] name group =

<HPD>grpo</HPD>,

<HPV>ts</HPV>*,
<HPV>name</HPV>,
(
<HPV>ts</HPV>*,
<HPV>connector</HPV>,
<HPV>ts</HPV>*,
<HPV>name</HPV>)*,

<HPV>ts</HPV>*,
<HPD>grpc</HPD></PROD>
<PROD>[70] ts =
<HPV>s</HPV> |
<HPC>Ee</HPC> |
<HPV>parameter entity reference</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Only one type of
<HPV>connector</HPV> should be used
in a single
<HPV>name group</HPV> or
<HPV>name token group</HPV>.</P>
<NT>No specific type of
<HPV>connector</HPV> is mandated,
so that a group defined in an entity can be referenced as both
a
<HPV>model group</HPV> (where the specific connector is meaningful)
and a
<HPV>name group</HPV> (where it is not).</NT>
<P>A token can occur only once
in a single
<HPV>name group</HPV> or
<HPV>name token group</HPV>.</P>
<P>A
<HPV>parameter entity reference</HPV> can be used
anywhere in a group that a token could occur.
The entity must consist of one or more of the consecutive complete tokens
that follow the
<HPV>ts</HPV> in which the reference occurs in the same group
(i.e. at the same nesting level),
together with any surrounding or intervening
<HPV>ts</HPV> separators
and any intervening connectors.
The entity must end within the same group.</P>
<P>An
<HPC>Ee</HPC> can occur in a
<HPV>ts</HPV> only if:

<UL SPREAD="COMPACT">
<LI>the
<HPV>ts</HPV> follows a token
(as opposed to a
<HPV>connector</HPV>,
<HPD>grpo</HPD>, or
<HPD>dtgo</HPD>);
and</LI>
<LI>the reference to the entity the
<HPC>Ee</HPC> terminates
occurs in the same group
(i.e. at the same nesting level).</LI></UL></P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The number of tokens in a group cannot exceed the "GRPCNT" quantity.</P>
<H3>Declaration Separator</H3>
<PROD>[71] ds =

<HPV>s</HPV> |
<HPC>Ee</HPC> |

<HPV>parameter entity reference</HPV> |

<HPV>comment declaration</HPV> |

<HPV>processing instruction</HPV> |

<HPV>marked section declaration</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>parameter entity reference</HPV> in a
<HPV>ds</HPV>
must refer to an entity
that consists of zero or more complete markup declarations
and/or
<HPV>ds</HPV> separators.</P>
<P>An
<HPC>Ee</HPC> can occur in a
<HPV>ds</HPV> only if the reference
to the entity it terminates occurs in a
<HPV>ds</HPV> in the same parameter.</P>
<H3>Associated Element Type</H3>
<PROD>[72] associated element type =

<HPV>generic identifier</HPV> |
<HPV>name group</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Each
<HPV>name</HPV> in the
<HPV>name group</HPV> must be a

<HPV>generic identifier</HPV>.
<REV REFID="AMEND1">
<P>A
<HPV>generic identifier</HPV> can be a valid

<HPV>associated element type</HPV>
whether or not it is specified as an
<HPV>element type</HPV>
in the document type definition.</P>
<NT>This provision makes it easier to use public definitions
that name a large set of generic identifiers
in conjunction with a more restrictive document type
that does not permit all of them.</NT></REV></P>
<H3>External Identifier</H3>
<PROD>[73] external identifier =
("SYSTEM" |
("PUBLIC",
<HPV>ps</HPV>+,
<HPV>public identifier</HPV>)),
(
<HPV>ps</HPV>+,
<HPV>system identifier</HPV>)?</PROD>
<PROD>[74] public identifier =

<HPV>minimum literal</HPV></PROD>
<PROD>[75] system identifier =
(
<HPD>lit</HPD>,
<HPV>system data</HPV>,
<HPD>lit</HPD>) |
(
<HPD>lita</HPD>,
<HPV>system data</HPV>,
<HPD>lita</HPD>)</PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>system identifier</HPV> can be omitted if the system can generate it
from the
<HPV>public identifier</HPV> and/or other information available to it.
<REV REFID="AMEND1">The generated
<HPV>system identifier</HPV> must be the same
for all uses of the
<HPV>external identifier</HPV>,
except in the case of the default entity,
where it must be the same
for all references with a given undeclared entity name.</REV></P>
<P>If "FORMAL YES" is specified on the
<HPV>SGML declaration</HPV>,
a
<HPV>public identifier</HPV> is interpreted as
a
<HPV>formal public identifier</HPV> (see 10.2)
and a formal public identifier error can occur.</P>
<NT>It is still a
<HPV>minimum literal</HPV>,
and all requirements pertaining to minimum literals apply.</NT>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of a
<HPV>system identifier</HPV>, exclusive of delimiters,
cannot exceed the "LITLEN" quantity.</P>
<H4>Capacities</H4>
<LOSTDATA></LOSTDATA>
<P>The number of characters of
<HPV>entity text</HPV>
counted towards the "ENTCHCAP" capacity
for an
<HPV>external identifier</HPV> is
that of its
<HPV>system identifier</HPV> component,
<REV REFID="AMEND1">added to that of its
<HPV>public identifier</HPV> component</REV>
(and exclusive of delimiters).</P>
<H3>Minimum Literal</H3>
<PROD>[76] minimum literal =
(
<HPD>lit</HPD>,
<HPV>minimum data</HPV>,
<HPD>lit</HPD>) |
(
<HPD>lita</HPD>,
<HPV>minimum data</HPV>,
<HPD>lita</HPD>)</PROD>
<PROD>[77] minimum data =

<HPV>minimum data character</HPV>*</PROD>
<PROD>[78] minimum data character =

<HPT>RS</HPT> |
<HPT>RE</HPT> |
<HPT>SPACE</HPT> |

<HPC>LC Letter</HPC> |
<HPC>UC Letter</HPC> |

<HPC>Digit</HPC> |
<HPC>Special</HPC></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>minimum literal</HPV> is interpreted
by ignoring
<HPT>RS</HPT>
and replacing a sequence of
one or more
<HPT>RE</HPT> and/or
<HPT>SPACE</HPT> characters
with a single
<HPT>SPACE</HPT>,
<REV REFID="AMEND1">except that such a sequence is ignored
if it occurs at the start or end of the
<HPV>minimum literal</HPV>.</REV></P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of an interpreted
<HPV>minimum literal</HPV>,
exclusive of delimiters,
cannot exceed the "LITLEN" quantity of the reference quantity set,
regardless of the concrete syntax used.</P>
<H2>Formal Public Identifier</H2>
<PROD>[79] formal public identifier =

<HPV>owner identifier</HPV>, "//",
<HPV>text identifier</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>formal public identifier</HPV> cannot contain consecutive solidi
("//")
except where expressly permitted by this sub-clause.</P>
<NT>As a
<HPV>public identifier</HPV> is a
<HPV>minimum literal</HPV>,

<HPT>RS</HPT> characters are removed, and sequences of
one or more
<HPT>RE</HPT> and/or
<HPT>SPACE</HPT> characters
replaced by a single
<HPT>SPACE</HPT>,
prior to interpretation as a
<HPV>formal public identifier</HPV>.
The
<HPV>minimum literal</HPV> length limitation applies to the interpreted text
(see 10.1.7.1).</NT>
<H3>Owner Identifier</H3>
<PROD>[80] owner identifier =

<HPV>ISO owner identifier</HPV> |

<HPV>registered owner identifier</HPV> |

<HPV>unregistered owner identifier</HPV></PROD>
<LOSTDATA></LOSTDATA>
<NT>In formulating an
<HPV>owner identifier</HPV>,
standards such as ISO 3166 can be helpful.</NT>
<H4>ISO Owner Identifier</H4>
<PROD>[81] ISO owner identifier =

<HPV>minimum data</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The usual form of an
<HPV>ISO owner identifier</HPV> can be used only
when the
<HPV>public identifier</HPV> identifies an ISO publication
or is assigned within one.
It consists of the ISO publication number, without the language suffix.</P>
<NT>For example, the
<HPV>ISO owner identifier</HPV>
for public text defined in this document is
<Q>ISO 8879-1986</Q>
in all translations.
If the public text is translated,
that fact is indicated by specifying the appropriate

<HPV>public text language</HPV> in the
<HPV>text identifier</HPV>.</NT>
<P>A special form of
<HPV>ISO owner identifier</HPV> can be used only
when the public text is an ISO registered character set
and the
<HPV>public text class</HPV> is "CHARSET".
It consists of the string
<Q>ISO Registration Number </Q>,
followed by the registration number of the character set.</P>
<H4>Registered Owner Identifier</H4>
<PROD>[82] registered owner identifier =
"+//" ,
<HPV>minimum data</HPV></PROD>
<LOSTDATA></LOSTDATA>
<NT>A
<HPV>registered owner identifier</HPV> could be a citation of a national
or industry standard, or some other unique identifier
assigned in accordance with ISO 9070.</NT>
<H4>Unregistered Owner Identifier</H4>
<PROD>[83] unregistered owner identifier =
"-//" ,
<HPV>minimum data</HPV></PROD>
<LOSTDATA></LOSTDATA>
<NT>An
<HPV>unregistered owner identifier</HPV> could be a
(presumably unique) designation created by a trade organization
or other user community, or by an individual.</NT>
<H3>Text Identifier</H3>
<PROD>[84] text identifier =

<HPV>public text class</HPV>,
<HPT>SPACE</HPT>,

<HPV>unavailable text indicator</HPV>?,

<HPV>public text description</HPV>, "//" ,
(
<HPV>public text language</HPV> |

<HPV>public text designating sequence</HPV>),
("//",
<HPV>public text display version</HPV>)?</PROD>
<PROD>[85] unavailable text indicator = "-//"</PROD>
<LOSTDATA></LOSTDATA>
<P>If the
<HPV>unavailable text indicator</HPV> is present,
the text is unavailable public text;
otherwise, it is available public text.</P>
<P>If the
<HPV>public text class</HPV> is "CHARSET",
the
<HPV>text identifier</HPV> includes
a
<HPV>public text designating sequence</HPV>;
otherwise, it includes a
<HPV>public text language</HPV>.</P>
<P>A
<HPV>text identifier</HPV> cannot be the same as
another
<HPV>text identifier</HPV>
in a
<HPV>formal public identifier</HPV> that has
the same
<HPV>owner identifier</HPV>.</P>
<NT>If two public texts with the same owner have the same public text description,
they must be of different classes, versions, etc.</NT>
<H4>Public Text Class</H4>
<PROD>[86] public text class =

<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>name</HPV> must be one that identifies an SGML construct
in the following list:

<DL SPREAD="COMPACT" TERMHI="0" TSIZE="14">
<DT>Name</DT>
<DD>
<EM>SGML construct</EM></DD>
<DT>CAPACITY</DT>
<DD>
<EM>capacity set</EM></DD>
<DT>CHARSET</DT>
<DD>
<EM>character data</EM></DD>
<DT>DOCUMENT</DT>
<DD>
<EM>SGML document</EM></DD>
<DT>DTD</DT>
<DD>
<EM>document type declaration subset</EM></DD>
<DT>ELEMENTS</DT>
<DD>
<EM>element set</EM></DD>
<DT>ENTITIES</DT>
<DD>
<EM>entity set</EM></DD>
<DT>LPD</DT>
<DD>
<EM>link type declaration subset</EM></DD>
<DT>NONSGML</DT>
<DD>
<EM>non-SGML data entity</EM></DD>
<DT>NOTATION</DT>
<DD>
<EM>character data</EM></DD>
<DT>SHORTREF</DT>
<DD>
<EM>short reference set</EM></DD>
<DT>SUBDOC</DT>
<DD>
<EM>SGML subdocument entity</EM></DD>
<DT>SYNTAX</DT>
<DD>
<EM>concrete syntax</EM></DD>
<DT>TEXT</DT>
<DD>
<EM>SGML text entity</EM></DD></DL></P>
<P>The
<HPV>name</HPV> must be entered with upper-case letters.</P>
<NT>When appropriate, a system can use the
<HPV>public text class</HPV>
to determine strategies for converting the public text
from its interchange form into a referenceable entity
that uses the system character set and concrete syntax.</NT>
<H4>Public Text Description</H4>
<PROD>[87] public text description =

<HPV>ISO text description</HPV> |
<HPV>minimum data</HPV></PROD>
<PROD>
<REV REFID="AMEND1">[87.1] ISO text description =
<HPV>minimum data</HPV></REV></PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>ISO text description</HPV> can be used only
when the
<HPV>public identifier</HPV> identifies an ISO publication.
It consists of the last element of the publication title,
without the part number designation (if any).</P>
<NT>For example, the
<HPV>ISO text description</HPV> for ISO 8632/4 is

<Q>Clear text encoding</Q>.</NT>
<H4>Public Text Language</H4>
<PROD>[88] public text language =
<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>public text language</HPV> must be a
<HPV>name</HPV>,
entered with upper-case letters.
<REV REFID="AMEND1">The
<HPV>name</HPV> should be the two-character language code from ISO 639</REV>
that identifies the principal natural language used in the public text.

<NOTEL>
<LI>The natural language will affect the usability of some public test classes
more than others.</LI>
<LI>The portions of text most likely to be influenced by a natural language
include the data, defined names, and comments.</LI>
<LI>A system can use the
<HPV>public text language</HPV> to facilitate
automatic language translation.</LI></NOTEL></P>
<H4>Public Text Designating Sequence</H4>
<PROD>[89] public text designating sequence =

<REV REFID="AMEND1">
<HPV>minimum data</HPV></REV></PROD>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">The
<HPV>minimum data</HPV> should be the external form of</REV>a designating escape sequence prescribed by ISO 2022
for the character set referenced by the
<HPV>public identifier</HPV>.
If the public text is an ISO registered character set,
<REV REFID="AMEND1">the designating escape sequence should be a</REV>
registered escape sequence for that set.

<NOTEL>
<LI>For example, the external form of a the registered G0 designating sequence
for the graphic characters of ISO 646 IRV (registered character set 002) is:

<XMP>ESC 2/8 4/0</XMP>
<REV REFID="AMEND1">The full set of 128 characters, which is not registered, should be designed by:

<XMP>ESC 2/5 4/0</XMP></REV></LI>
<LI>For registered character sets, the
<HPV>public text designating sequence</HPV>
uniquely identifies the public text.
<REV REFID="AMEND1">For other character sets, it should uniquely identify the public text</REV>
with respect to a particular
<HPV>owner identifier</HPV>.</LI></NOTEL></P>
<H4>Public Text Display Version</H4>
<PROD>[90] public text display version =

<HPV>minimum data</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>public text display version</HPV> must be omitted
if the
<HPV>public text class</HPV> is "CAPACITY", "CHARSET",
"NOTATION", or "SYNTAX".
For other classes, if the public text is device-dependent,
the text identifier must include a
<HPV>public text display version</HPV>
that describes the devices supported or coding scheme used.</P>
<P>When a system accesses public text
for which a
<HPV>public text display version</HPV> could have been specified
but was not,
it must substitute the best available device-dependent version
for the display device in use.
If there is none, no substitution occurs.</P>
<NT>This mechanism is particulary useful with character entity sets.</NT>
<H2>Comment Declaration</H2>
<PROD>[91] comment declaration =

<HPD>mdo</HPD>,
(
<HPV>comment</HPV>, (
<HPV>s</HPV> |
<HPV>comment</HPV>)*)?,

<HPD>mdc</HPD></PROD>
<PROD>[92] comment =

<HPD>com</HPD>,
<HPV>SGML character</HPV>*,
<HPD>com</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>No markup is recognized in a
<HPV>comment</HPV>,
other than the
<HPD>com</HPD> delimiter that terminates it.</P>
<H2>Marked Section Declaration</H2>
<PROD>[93] marked section declaration =

<HPV>marked section start</HPV>,

<HPV>status keyword specification</HPV>,

<HPD>dso</HPD>,

<HPV>marked section</HPV>,

<HPV>marked section end</HPV></PROD>
<PROD>[94] marked section start =
<HPD>mdo</HPD>,
<HPD>dso</HPD></PROD>
<PROD>[95] marked section end =
<HPD>msc</HPD>,
<HPD>mdc</HPD></PROD>
<PROD>[96] marked section =
<HPV>SGML character</HPV>*</PROD>
<LOSTDATA></LOSTDATA>
<P>The marked section must comply
with the syntactic and semantic requirements
that govern the context in which
the
<HPV>marked section declaration</HPV> occurs.</P>
<P>A
<HPV>marked section end</HPV> that occurs
outside of a
<HPV>marked section declaration</HPV>
is an error.</P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The number of open marked section declarations
cannot exceed the "TAGLVL" quantity.</P>
<H3>Status Keyword Specification</H3>
<PROD>[97] status keyword specification =

<REV REFID="AMEND1">(
<HPV>ps</HPV>+, (
<HPV>status keyword</HPV> | "TEMP"))*,</REV>

<HPV>ps</HPV>*</PROD>
<PROD>[100] status keyword =
"CDATA" | "IGNORE" |
"INCLUDE" | "RCDATA"</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="9">
<DT>IGNORE</DT>
<DD>specifies that the section is treated
as though there were no characters in the
<HPV>marked section</HPV>,
<REV REFID="AMEND1">except that a nested
<HPV>marked section start</HPV>
or
<HPV>marked section end</HPV></REV>
is recognized so that the correct ending can be found.</DD>
<DT>INCLUDE</DT>
<DD>specifies that the
<HPV>marked section</HPV> is not to be ignored.</DD>
<DT>CDATA</DT>
<DD>specifies that the
<HPV>marked section</HPV>
is treated as
<HPV>character data</HPV>.</DD>
<DT>RCDATA</DT>
<DD>specifies that the
<HPV>marked section</HPV> is treated
as
<HPV>replaceable character data</HPV>.</DD>
<DT>TEMP</DT>
<DD>identifies the section as a temporary part of the document
that might need to be removed at a later time.</DD></DL></P>
<P>In the event of a conflicting specification,
the status keywords have the following priority
(highest shown first):

<SL SPREAD="COMPACT">
<LI>"IGNORE"</LI>
<LI>"CDATA"</LI>
<LI>"RCDATA"</LI>
<LI>"INCLUDE"</LI></SL></P>
<P>If none is specified, "INCLUDE" is assumed.
<REV REFID="AMEND1">
<P>If the effective status is "CDATA" or "RCDATA",
a
<HPV>marked section declaration</HPV> is terminated by the first

<HPV>marked section end</HPV>.</P>
<NT>A nested
<HPV>marked section declaration</HPV>
within the "CDATA" or "RCDATA" marked section
in the same entity could not occur,
as the markup would not be recognized.</NT></REV></P>
<P>If the effective status is "IGNORE",
an
<HPC>Ee</HPC> is not allowed in the
<HPV>marked section</HPV>.</P>
<NT>The scan of "IGNORE", "CDATA", or "RCDATA"
marked section ignores virtually all markup but marked section ends.
As a result, processing instructions, attribute values, literals,
character data elements, and comments are not recognized to be such,
so their characters are also scanned.
This could cause erroneous results
if the characters look like marked sections.
In most cases, problems can be avoided
by entering such characters with references, instead of directly.</NT>
<H2>Entity Declaration</H2>
<PROD>[101] entity declaration =

<HPD>mdo</HPD>, "ENTITY",

<HPV>ps</HPV>+,
<HPV>entity name</HPV>,
<HPV>ps</HPV>+,
<HPV>entity text</HPV>,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<LOSTDATA></LOSTDATA>
<H3>Entity Name</H3>
<PROD>[102] entity name =

<HPV>general entity name</HPV> |

<HPV>parameter entity name</HPV></PROD>
<PROD>[103] general entity name =

<HPV>name</HPV> | (
<HPD>rni</HPD>, "DEFAULT")</PROD>
<PROD>[104] parameter entity name =

<HPD>pero</HPD>,
<HPV>ps</HPV>+,
<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>DEFAULT</DT>
<DD>means the entity is the default entity.</DD></DL>
<REV REFID="AMEND1">
<P>The
<HPD>pero</HPD> in production 104
is recognized as a delimiter in this context without a contextual constraint.</P></REV></P>
<P>An attempt to redefine an entity is ignored but is not an error.</P>
<NT>This requirement allows an entity declaration
in a document type declaration subset
to take priority over a later declaration of the same entity
in a public document type definition.</NT>
<P>The
<HPV>ps</HPV> in a
<HPV>parameter entity name</HPV> is required,
even though it follows a delimiter.</P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>name</HPV> in a
<HPV>parameter entity name</HPV> must be at least
<REV REFID="AMEND1">the number of characters in a
<HPD>pero</HPD> delimiter string</REV>
shorter than the "NAMELEN" quantity.</P>
<H4>Capacities</H4>
<LOSTDATA></LOSTDATA>
<P>Points are counted towards the "ENTCAP" capacity
for the default entity,
and for each unique entity name that is defaulted in one or more references.</P>
<P>Points are counted towards the "ENTCHCAP" capacity
for the default entity.</P>
<H3>Entity Text</H3>
<PROD>[105] entity text =

<HPV>parameter literal</HPV> |
<HPV>data text</HPV> |

<HPV>bracketed text</HPV> |

<HPV>external entity specification</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>If a
<HPV>parameter literal</HPV> alone
is specified as the
<HPV>entity text</HPV>,
the interpreted
<HPV>parameter literal</HPV>
is the replacement text of the entity.</P>
<P>An
<HPC>Ee</HPC> is deemed to be present
at the end of the replacement text;
it is not entered explicitely.
<REV REFID="AMEND1">
<NT>An entity whose text includes a
<HPV>parameter literal</HPV>
is considered a single entity
even if the literal contained entity references that were resolved
when the literal was interpreted.</NT></REV></P>
<H3>Data Text</H3>
<LOSTDATA></LOSTDATA>
<P>Data text is treated as
<HPV>character data</HPV> when referenced,
regardless of the context in which the entity reference occurs.
It is specified as a
<HPV>parameter literal</HPV>,
whose characters, after resolution of references in the usual manner,
will comprise the
<HPV>entity text</HPV>.
<PROD>[106] data text =
("CDATA" | "SDATA" | "PI"),

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV></PROD></P>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>CDATA</DT>
<DD>means the interpreted
<HPV>parameter literal</HPV>
is the replacement text of a character data entity.</DD>
<DT>SDATA</DT>
<DD>means the interpreted
<HPV>parameter literal</HPV>
is the replacement text of a specific character data entity.</DD>
<DT>PI</DT>
<DD>means the interpreted
<HPV>parameter literal</HPV>
<REV REFID="AMEND1">is the replacement text of a processing instruction entity.</REV></DD></DL></P>
<P>"CDATA" or "SDATA" can be specified only
if the
<HPV>entity name</HPV> is a
<HPV>general entity name</HPV>.</P>
<P>A
<HPV>processing instruction</HPV> that returns data must be defined as
an "SDATA" entity.

<NOTEL>
<LI>A "CDATA" or "SDATA" entity
<REV REFID="AMEND1">must be referenced in a context in which a data character can occur,</REV>
and a "PI" entity
in a context in which a
<HPV>processing instruction</HPV> could occur.</LI>
<LI>"SDATA" is normally specified
if the entity would be redefined for different applications, systems,
or output devices;
for example, if the data contained processing instructions,
<REV REFID="AMEND1">or characters not present in the syntax-reference character set.</REV></LI>
<LI>
<REV REFID="AMEND1">No data content notation applies to an internal data entity
that is the subject of an explicit content reference.
To specify a notation, the entity must be declared as an external data entity.</REV></LI></NOTEL></P>
<H3>Bracketed Text</H3>
<PROD>[107] bracketed text =
("STARTTAG" | "ENDTAG" |
"MS" | "MD"),

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>where the keywords mean that the entity consists of the interpreted

<HPV>parameter literal</HPV> bracketed with delimiters as follows:

<DL TERMHI="2" TSIZE="13">
<DT>STARTTAG</DT>
<DD>means preceded by
<HPD>stago</HPD> and followed by
<HPD>tagc</HPD>.</DD>
<DT>ENDTAG</DT>
<DD>means preceded by
<HPD>etago</HPD> and followed by
<HPD>tagc</HPD>.</DD>
<DT>MS</DT>
<DD>means preceded by a
<HPV>marked section start</HPV>
and followed by a
<HPV>marked section end</HPV>.</DD>
<DT>MD</DT>
<DD>means preceded by
<HPD>mdo</HPD> and followed by
<HPD>mdc</HPD>.</DD></DL></P>
<NT>Bracketed text is simply text with delimiter characters;
there is no requirement that the entities form valid start-tags
or other constructs.
As usual, the validity of the entity is determined in context
whenever the entity is referenced.</NT>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of an interpreted
<HPV>parameter literal</HPV>
in
<HPV>bracketed text</HPV>
cannot exceed the "LITLEN" quantity,
less the length of the bracketing delimiters.</P>
<H3>External Entity Specification</H3>
<PROD>[108] external entity specification =

<HPV>external identifier</HPV>,
(
<HPV>ps</HPV>+,
<HPV>entity type</HPV>)?</PROD>
<PROD>[109] entity type =
"SUBDOC" |

<REV REFID="AMEND1">(("CDATA" | "NDATA" | "SDATA"),</REV>

<HPV>ps</HPV>+,
<HPV>notation name</HPV>,

<REV REFID="AMEND1">
<HPV>data attribute specification</HPV>?)</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>SUBDOC</DT>
<DD>means the entity is an
<HPV>SGML subdocument entity</HPV>.</DD>
<DT>NDATA</DT>
<DD>means the entity is a
<HPV>non-SGML data entity</HPV>.
<REV REFID="AMEND1">
<DT>CDATA</DT>
<DD>means the entity is a
<HPV>character data entity</HPV>.</DD>
<DT>SDATA</DT>
<DD>means the entity is a
<HPV>specific character data entity</HPV>.</DD></REV></DD></DL></P>
<P>The
<HPV>entity type</HPV> can be specified
only if the entity
<HPV>name</HPV> is a
<HPV>general entity name</HPV>.</P>
<P>If the
<HPV>entity type</HPV> is omitted,
the entity is an
<HPV>SGML text entity</HPV>.</P>
<P>The
<HPV>notation name</HPV> must be declared
in the same document type definition as the entity.
<REV REFID="AMEND1">It need not have been defined prior to this declaration,
but must be defined prior to a reference to the entity.</REV></P>
<P>
<REV REFID="AMEND1">A data entity can reference (in its own notation)
other data entities and SGML subdocument entities.
The referenced entities,
and any data entities referenced within a nested structure of data entities,
should be declared
in the same document type definitions as the original data entity.</REV></P>
<P>"SUBDOC" can be specified only if "SUBDOC YES" is
specified on the
<HPV>SGML declaration</HPV>.</P>
<H1>Markup Declarations: Document Type Definition</H1>
<LOSTDATA></LOSTDATA>
<H2>Document Type Declaration</H2>
<PROD>[110] document type declaration =

<HPD>mdo</HPD>, "DOCTYPE",

<HPV>ps</HPV>+,
<HPV>document type name</HPV>,
(
<HPV>ps</HPV>+,
<HPV>external identifier</HPV>)?,
(
<HPV>ps</HPV>+,
<HPD>dso</HPD>,

<HPV>document type declaration subset</HPV>,
<HPD>dsc</HPD>)?,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[111] document type name =

<HPV>generic identifier</HPV></PROD>
<PROD>[112] document type declaration subset =
(
<HPV>entity set</HPV> |

<HPV>element set</HPV> |

<HPV>short reference set</HPV>)*</PROD>
<PROD>[113] entity set =
(
<HPV>entity declaration</HPV> |
<HPV>ds</HPV>)*</PROD>
<PROD>[114] element set =
(
<HPV>element declaration</HPV> |

<HPV>attribute definition list declaration</HPV> |

<HPV>notation declaration</HPV> |

<HPV>ds</HPV>)*</PROD>
<PROD>[115] short reference set =
(
<HPV>entity declaration</HPV> |

<HPV>short reference mapping declaration</HPV> |

<HPV>short reference use declaration</HPV> |

<HPV>ds</HPV>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>document type name</HPV> must be a
<HPV>generic identifier</HPV>
that does not occur as a
<HPV>document type name</HPV>
or
<HPV>link type name</HPV>
in the same
<HPV>prolog</HPV>.</P>
<P>The
<HPV>external identifier</HPV> points to an entity that is
referenced at the end of the declaration subset
and is considered to be part (or all) of it.
The effective document type definition is the combination of
the declarations entered in the subset and the external ones.</P>
<NT>A parameter entity declaration in the subset will have priority
over another declaration for that entity in the external entity,
as the external entity is parsed later.</NT>
<P>A
<HPV>document type declaration</HPV> must contain an
<HPV>element declaration</HPV>
for the
<HPV>document type name</HPV>.</P>
<P>A
<HPV>short reference set</HPV> is permitted
only in the base document type declaration.
<REV REFID="AMEND1">
<P>An
<HPC>Ee</HPC> or
<HPV>parameter entity reference</HPV>
cannot occur in a
<HPV>document type declaration</HPV>,
except within the
<HPV>document type declaration subset</HPV>.</P></REV></P>
<H2>Element Declaration</H2>
<PROD>[116] element declaration =

<HPD>mdo</HPD>, "ELEMENT",

<HPV>ps</HPV>+,
<HPV>element type</HPV>,
(
<HPV>ps</HPV>+,
<HPV>omitted tag minimization</HPV>)?,

<HPV>ps</HPV>+, (
<HPV>declared content</HPV> |
<HPV>content model</HPV>),

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>The order in which elements and characters occur within an element
in a document instance must comply with the element type definition
specified in the element declaration.</P>
<P>The
<HPV>omitted tag minimization</HPV> parameter and its preceding
<HPV>ps</HPV>
can be omitted only if "OMITTAG NO"
is specified on the
<HPV>SGML declaration</HPV>.</P>
<H3>Element type</H3>
<PROD>[117] element type =

<HPV>generic identifier</HPV> |
<HPV>name group</HPV> |

<HPV>ranked element</HPV> |
<HPV>ranked group</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Within a document type definition,
a
<HPV>generic identifier</HPV> can be specified only once
in an
<HPV>element type</HPV> parameter,
<REV REFID="AMEND1">and it cannot be the same as a
<HPV>rank stem</HPV>,
or as the the
<HPV>generic identifier</HPV>
that is derived by appending the
<HPV>rank suffix</HPV> of a
<HPV>ranked element</HPV>
to its
<HPV>rank stem</HPV>.</REV></P>
<P>If the
<HPV>element type</HPV> is a group,
the group members are defined in the order their names occur,
and the definition applies to each of them.</P>
<P>If the
<HPV>element type</HPV> is a
<HPV>name group</HPV>,
each
<HPV>name</HPV> is a
<HPV>generic identifier</HPV>.</P>
<H4>Ranked Element</H4>
<PROD>[118] ranked element =

<HPV>rank stem</HPV>,
<HPV>ps</HPV>+,
<HPV>rank suffix</HPV></PROD>
<PROD>[119] ranked group =

<HPD>grpo</HPD>,

<HPV>ts</HPV>*,
<HPV>rank stem</HPV>,
(
<HPV>ts</HPV>*,
<HPV>connector</HPV>,
<HPV>ts</HPV>*,
<HPV>rank stem</HPV>)*,

<HPV>ts</HPV>*,
<HPD>grpc</HPD>,

<HPV>ps</HPV>+,
<HPV>rank suffix</HPV></PROD>
<PROD>[120] rank stem =
<HPV>name</HPV></PROD>
<PROD>[121] rank suffix =
<HPV>number</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>generic identifier</HPV> specified by a
<HPV>ranked element</HPV>
or member of a
<HPV>ranked group</HPV>
is the
<HPV>rank stem</HPV> with the
<HPV>rank suffix</HPV> appended.</P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The length of a
<HPV>generic identifier</HPV>
cannot exceed the "NAMELEN" quantity.</P>
<H3>Omitted tag minimization</H3>
<PROD>[122] omitted tag minimization =

<HPV>start-tag minimization</HPV>,
<HPV>ps</HPV>+,

<HPV>end-tag minimization</HPV></PROD>
<PROD>[123] start-tag minimization = "O" |
<HPD>minus</HPD></PROD>
<PROD>[124] end-tag minimization = "O" |
<HPD>minus</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="9">
<DT>O</DT>
<DD>means that omission of the tag under the conditions specified in 7.3.1
is not a markup error.</DD>
<DT>minus</DT>
<DD>means that omission of the tag under the conditions specified in 7.3.1
is a markup error.
<REV REFID="AMEND1">
<P>The
<HPD>minus</HPD> in productions 123 and 124
is recognized as a delimiter in this context without a contextual constraint.</P></REV></DD></DL></P>
<P>
<HPD>minus</HPD> should be specified for start-tag minimization
if omission is prohibited by 7.3.1.</P>
<P>"O" should be specified for end-tag minimization
if the element has
<REV REFID="AMEND1">a content reference attribute</REV>
or a declared value of "EMPTY".</P>
<NT>Specifying "O" serves as a reminder that
empty elements do not have end-tags
(although this has nothing to do with markup minimization).</NT>
<H3>Declared Content</H3>
<PROD>[125] declared content =
"CDATA" | "RCDATA" | "EMPTY"</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="9">
<DT>RCDATA</DT>
<DD>means that the
<HPV>content</HPV> is
<HPV>replaceable character data</HPV>.</DD>
<DT>CDATA</DT>
<DD>means that the
<HPV>content</HPV> is
<HPV>character data</HPV>.</DD>
<DT>EMPTY</DT>
<DD>means that the
<HPV>content</HPV> is empty.</DD></DL></P>
<H3>Content Model</H3>
<PROD>[126] content model =
(
<HPV>model group</HPV> | "ANY"),
(
<HPV>ps</HPV>+,
<HPV>exceptions</HPV>)?</PROD>
<PROD>[127] model group =

<HPD>grpo</HPD>,

<HPV>ts</HPV>*,
<HPV>content token</HPV>,
(
<HPV>ts</HPV>*,
<HPV>connector</HPV>,

<HPV>ts</HPV>*,
<HPV>content token</HPV>)*,

<HPV>ts</HPV>*,
<HPD>grpc</HPD>,

<HPV>occurrence indicator</HPV>?</PROD>
<PROD>[128] content token =

<HPV>primitive content token</HPV> |
<HPV>model group</HPV></PROD>
<PROD>[129] primitive content token =
(
<HPD>rni</HPD>, "PCDATA") |

<HPV>element token</HPV> |
<HPV>data tag group</HPV></PROD>
<PROD>[130] element token =

<HPV>generic identifier</HPV>,
<HPV>occurrence indicator</HPV>?</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="9">
<DT>ANY</DT>
<DD>
<REV REFID="AMEND1">means the
<HPV>content model</HPV> is
an optional and repeatable
<HPD>or</HPD> group
whose members are
<Q>#PCDATA</Q> and all of the GIs specified
as element types in the same document type definition.</REV></DD>
<DT>PCDATA</DT>
<DD>means
<HPV>parsed character data</HPV> is allowed.

<NT>The
<HPD>rni</HPD> distinguishes this keyword
from an
<HPV>element token</HPV> of
<Q>PCDATA</Q></NT></DD></DL></P>
<P>If
<Q>#PCDATA</Q> or a
<HPV>data-tag group</HPV>
is present in a
<HPV>model group</HPV>,
the element's
<HPV>content</HPV> is
<HPV>mixed content</HPV>;
if not, it is
<HPV>element content</HPV>.
<REV REFID="AMEND1">
<NT>It is recommended that
<Q>#PCDATA</Q> be used only
when data characters are to be permitted
anywhere in the
<HPV>content</HPV> of the element;
that is, in a
<HPV>content model</HPV> where it is the sole token,
or where
<HPD>or</HPD> is the only connector used in any
<HPV>model</HPV> group.

<P>This recommendation is made because separator characters,
which are recognized as separators in
<HPV>element content</HPV>,
are treated as data in
<HPV>mixed content</HPV>.
In content models where this recommendation is not followed, such as:

<XMP>(x, #PCDATA)</XMP>
an
<HPT>RE</HPT> occurring before the start-tag of
<Q>x</Q>
would (because it is data) imply the start of an
<Q>x</Q> element
(because an
<Q>x</Q> is contextually required).
The actual start-tag for
<Q>x</Q> would then be treated as an error
(because a second
<Q>x</Q> is not permitted).</P>
<P>An equivalent for a non-recommended content model can normally be obtained
by replacing
<Q>#PCDATA</Q> with the GI of an element
whose content is
<Q>#PCDATA</Q> and both of whose tags can be omitted.</P>
<P>This recommendation should not be construed
as deprecating the use of the data-tag feature (see the note in 11.2.4.4),
but care should be taken with separator characters.</P></NT></REV></P>
<P>
<REV REFID="AMEND1">The elements and data characters of the
<HPV>content</HPV></REV>must conform to the
<HPV>content model</HPV>
by satisfying
<HPV>model group</HPV> tokens and
<HPV>exceptions</HPV>
in the following order of priority:

<OL>
<LI>a repetition of the most recent satisfied token,
if it has a
<HPD>rep</HPD> or
<HPD>plus</HPD> occurrence indicator;
or</LI>
<LI>some other token in a
<HPV>model group</HPV>,
possibly as modified by exclusion
<HPV>exceptions</HPV> (see 11.2.5);
or</LI>
<LI>a token in an inclusion
<HPV>exceptions</HPV> group (see 11.2.5.1).</LI></OL></P>
<NT>For example, in an instance of the following element:

<XMP>&lt;!element e (a+ | b)+></XMP>
successive
<Q>a</Q> elements will satisfy repetitions of the element token,
rather than repetitions of the model group.</NT>
<P>All data occurring between successive tags are considered to satisfy
a single
<Q>#PCDATA</Q> token,
even if some were declared to be character data by a marked section declaration.
<REV REFID="AMEND1">
<P>A
<HPV>generic identifier</HPV> can be a valid

<HPV>element token</HPV>
whether or not it is specified as an
<HPV>element type</HPV>
in the document type definition.</P>
<NT>This provision makes it easier to use public definitions
that name a large set of generic identifiers
in conjunction with a more restrictive document type
that does not permit all of them.</NT></REV></P>
<H4>Connector</H4>
<PROD>[131] connector =
<HPD>and</HPD> |
<HPD>or</HPD> |
<HPD>seq</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>If there is more than one
<HPV>content token</HPV> in a
<HPV>model group</HPV>,
the ordering and selection among their corresponding content
is determined by the
<HPV>connector</HPV>, as follows:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="7">
<DT>seq</DT>
<DD>All must occur, in the order entered.</DD>
<DT>and</DT>
<DD>All must occur, in any order.</DD>
<DT>or</DT>
<DD>One and only one must occur.</DD></DL></P>
<P>Only one kind of
<HPV>connector</HPV> can occur in a single
<HPV>model group</HPV>
(but a
<HPV>model group</HPV> nested within it could have a different
<HPV>connector</HPV>).
<REV REFID="AMEND1">
<P>A
<HPV>model group</HPV> with a single content token
is regarded as a
<HPD>seq</HPD> group.</P></REV></P>
<H4>Occurrence Indicator</H4>
<PROD>[132] occurrence indicator =
<HPD>opt</HPD> |
<HPD>plus</HPD> |
<HPD>rep</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>The corresponding content of each selected
<HPV>content token</HPV>
must occur once and only once unless the contrary is indicated
by the token's
<HPV>occurrence indicator</HPV> as follows:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="7">
<DT>opt</DT>
<DD>Optional (0 or 1 time).</DD>
<DT>plus</DT>
<DD>Required and repeatable (1 or more times).</DD>
<DT>rep</DT>
<DD>Optional and repeatable (0 or more times).</DD></DL></P>
<P>The
<Q>#PCDATA</Q> content token is regarded as having
an
<HPV>occurrence indicator</HPV> of
<HPD>rep</HPD>.</P>
<P>An inherently optional token is treated
as having an
<HPD>opt</HPD> occurrence indicator
if none is specified,
or as having a
<HPD>rep</HPD> occurrence indicator
if
<HPD>plus</HPD> is specified.</P>
<H4>Ambiguous Content Model</H4>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>content model</HPV> cannot be ambiguous;
that is,
an element or character string that occurs in the document instance
must be able to satisfy only one
<HPV>primitive content token</HPV>
<REV REFID="AMEND1">without looking ahead in the document instance.
The priority rules stated earlier in 11.2.4 are not considered
in determining whether a content model is ambiguous.</REV></P>
<NT>For example, the content model in:

<XMP>&lt;!element e ((a, b?), b)></XMP>
is ambiguous because after an
<Q>a</Q> element occurs,
a
<Q>b</Q>element could satisfy either of the remaining tokens.
The ambiguity can be avoided by using intermediate elements, as in:

<XMP>&lt;!element e (f, b)>
&lt;!element f (a, b?)></XMP>
Here the token satisfied by
<Q>b</Q> is determined unambiguously by
whether the
<Q>f</Q> element ends before the
<Q>b</Q> occurs.
(The theoretical basis of content models is discussed in annex H.)</NT>
<H4>Data Tag Group</H4>
<PROD>[133] data tag group =

<HPD>dtgo</HPD>,

<HPV>ts</HPV>*,
<HPV>generic identifier</HPV>,

<HPV>ts</HPV>*,
<HPD>seq</HPD>,

<HPV>ts</HPV>*,
<HPV>data tag pattern</HPV>,

<HPV>ts</HPV>*,
<HPD>dtgc</HPD>,

<REV REFID="AMEND1">
<HPV>occurrence indicator</HPV>?</REV></PROD>
<PROD>[134] data tag pattern =
(
<HPV>data tag template group</HPV> |

<HPV>data tag template</HPV>),
(
<HPV>ts</HPV>*,
<HPD>seq</HPD>,

<HPV>ts</HPV>*,
<HPV>data tag padding template</HPV>)?</PROD>
<PROD>[135] data tag template group =

<HPD>grpo</HPD>,

<HPV>ts</HPV>*,
<HPV>data tag template</HPV>,
(
<HPV>ts</HPV>*,
<HPD>or</HPD>,
<HPV>ts</HPV>*,
<HPV>data tag template</HPV>)*,

<HPV>ts</HPV>*,
<HPD>grpc</HPD></PROD>
<PROD>[136] data tag template =

<HPV>parameter literal</HPV></PROD>
<PROD>[137] data tag padding template =

<HPV>parameter literal</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>data tag group</HPV> is interpreted as a
<HPD>seq</HPD> group.
with two tokens: an element GI followed by
<Q>#PCDATA</Q>.</P>
<NT>For example, with the reference delimiter set, the
<HPV>model group</HPV>:

<XMP>([hours, (" :" | ":"), " "], minutes)</XMP>
is treated as though it were:

<XMP>((hours, #PCDATA), minutes)</XMP></NT>
<P>A
<HPV>data tag group</HPV> can only be present
in the base
<HPV>document type declaration</HPV>.</P>
<P>A
<HPV>parameter literal</HPV> in a
<HPV>data tag pattern</HPV>
is interpreted in the normal manner,
except that a numeric character reference to
a non-SGML character or
<HPV>function character</HPV> is prohibited.</P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>The content model nesting level
cannot exceed the "GRPLVL" quantity.</P>
<P>
<REV REFID="AMEND1">The grand total of the content tokens at all levels of a content model</REV>cannot exceed the "GRPGTCNT" quantity.</P>
<P>The length of an interpreted
<HPV>parameter literal</HPV>
in a
<HPV>data tag pattern</HPV>
cannot exceed the "DTEMPLEN" quantity.</P>
<H3>Exceptions</H3>
<PROD>[138] exceptions =
(
<HPV>exclusions</HPV>, (
<HPV>ps</HPV>+,
<HPV>inclusions</HPV>)?) |

<HPV>inclusions</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>exceptions</HPV> apply anywhere in an instance of the element,
including subelements
whose
<HPV>content</HPV> is
<HPV>mixed content</HPV>
or
<HPV>element content</HPV>.</P>
<P>At any point in a document instance,
if an element is both an applicable inclusion and an exclusion,
it is treated as an exclusion.</P>
<H4>Inclusions</H4>
<PROD>[139] inclusions =

<HPD>plus</HPD>,
<HPV>name group</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Inclusions modify the effect of model groups to which they apply
in the manner shown in the following example:
given that

<Q>Q</Q> is a generic identifier or group in the model group,

<Q>x</Q> is its occurrence indicator
(or empty if there is no occurrence indicator),
and
<Q>R1</Q> through
<Q>Rn</Q> are applicable inclusions,
then a token:

<XMP>Qx</XMP>
is treated as though as it were:

<XMP>(R1|R2|...|RN)*,(Q,(R1|R2|...|RN)*)x</XMP></P>
<P>An element that can satisfy an element token in the content model
is considered to do so, even if the element is also an inclusion.

<NOTEL>
<LI>Inclusions should not be used for contextual subelements.
They should be used only for elements that are not logically part
of the content at the point they occur in the document,
such as index entries or floating figures.</LI>
<LI>An
<HPT>RE</HPT> that follows an inclusion will normally be ignored,
while one that follows a proper subelement will be treated as data
(see 7.6.1).</LI></NOTEL></P>
<H4>Exclusions</H4>
<PROD>[140] exclusions =

<HPD>minus</HPD>,
<HPV>name group</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>Exclusions modify the effect of model groups to which they apply
by precluding options that would otherwise have been available
(just as though the user had chosen
to leave optional elements out of the document).</P>
<P>It is an error if an exclusion attempts to modify the effect of a
model group in any other way.
In particular, it is an error if:

<OL SPREAD="COMPACT">
<LI>an exclusion applies to tokens other than those in
<HPV>inclusions</HPV>,
those having an
<HPD>opt</HPD> or
<HPD>rep</HPD> occurrence indicator,
or those that are members of
<HPD>or</HPD> groups;
or</LI>
<LI>an exclusion attempts to change a token's required or optional status.

<NT>For example, it is prohibited to exclude all members of a required

<HPV>model group</HPV>, as the group would then no longer be required.</NT></LI></OL></P>
<H2>Attribute Definition List Declaration</H2>
<PROD>[141] attribute definition list declaration =

<HPD>mdo</HPD>, "ATTLIST",

<HPV>ps</HPV>+,

<REV REFID="AMEND1">(
<HPV>associated element type</HPV> |

<HPV>associated notation name</HPV>),</REV>

<HPV>ps</HPV>+,
<HPV>attribute definition list</HPV>,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[142] attribute definition list =

<HPV>attribute definition</HPV>,
(
<HPV>ps</HPV>+,
<HPV>attribute definition</HPV>)*</PROD>
<PROD>[143] attribute definition =

<HPV>attribute name</HPV>,

<HPV>ps</HPV>+,
<HPV>declared value</HPV>,

<HPV>ps</HPV>+,
<HPV>default value</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">An individual associated element type cannot be associated</REV>with another attribute definition list in the same declaration subset
in which this list occurs.</P>
<H3>Quantities</H3>
<LOSTDATA></LOSTDATA>
<P>The total number of attribute names and name tokens
in the
<HPV>attribute definition list</HPV>
cannot exceed the "ATTCNT" quantity.
<REV REFID="AMEND1">
<NT>Default values should not be considered in applying this rule.</NT></REV></P>
<H3>Attribute Name</H3>
<PROD>[144] attribute name =

<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>An
<HPV>attribute name</HPV> can be specified only once in the same

<HPV>attribute definition list</HPV>.
<REV REFID="AMEND1">
<P>Within a document type definition,
the same
<HPV>attribute name</HPV> should be used for all attributes having
a
<HPV>declared value</HPV> of "ID".</P>
<NT>Use of a common name for all ID attributes emphasizes the requirement
that an ID value must be unique within a document instance.</NT></REV></P>
<H3>Declared Value</H3>
<PROD>[145] declared value =
"CDATA" |

<REV REFID="AMEND1">"ENTITY" | "ENTITIES" |</REV>
"ID" |
"IDREF" | "IDREFS" |
"NAME" | "NAMES" |
"NMTOKEN" | "NMTOKENS" |
"NUMBER" | "NUMBERS" |
"NUTOKEN" | "NUTOKENS" |

<HPV>notation</HPV> |
<HPV>name token group</HPV></PROD>
<PROD>[146] notation =
"NOTATION" ,
<HPV>ps</HPV>+,
<HPV>name group</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>CDATA</DT>
<DD>means the
<HPV>attribute value</HPV> is
<HPV>character data</HPV>.</DD>
<DT>ENTITY</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>general entity name</HPV>.
<REV REFID="AMEND1">
<DT>ENTITIES</DT>
<DD>means the
<HPV>attribute value</HPV> is a

<HPV>general entity name list</HPV>.</DD></REV></DD>
<DT>ID</DT>
<DD>means the
<HPV>attribute value</HPV> is an
<HPV>id value</HPV>.</DD>
<DT>IDREF</DT>
<DD>means the
<HPV>attribute value</HPV> is an
<HPV>id reference value</HPV>.</DD>
<DT>IDREFS</DT>
<DD>means the
<HPV>attribute value</HPV> is an
<HPV>id reference list</HPV>.</DD>
<DT>NAME</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>name</HPV>.</DD>
<DT>NAMES</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>name list</HPV>.</DD>
<DT>NMTOKEN</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>name token</HPV>.</DD>
<DT>NMTOKENS</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>name token list</HPV>.</DD>
<DT>NUMBER</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>number</HPV>.</DD>
<DT>NUMBERS</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>number list</HPV>.</DD>
<DT>NUTOKEN</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>number token</HPV>.</DD>
<DT>NUTOKENS</DT>
<DD>means the
<HPV>attribute value</HPV> is a
<HPV>number token list</HPV>.</DD></DL></P>
<P>"ID" and "NOTATION" can each be declared
only once in the
<HPV>attribute definition list</HPV>.</P>
<P>A token cannot occur more than once in an
<HPV>attribute definition list</HPV>,
even in different groups.</P>
<P>"NOTATION" cannot be declared for an element
whose
<HPV>declared content</HPV> is "EMPTY".</P>
<H3>Default Value</H3>
<PROD>[147] default value =
((
<HPD>rni</HPD>, "FIXED",
<HPV>ps</HPV>+)?,

<HPV>attribute value specification</HPV>) |
(
<HPD>rni</HPD>,
("REQUIRED" | "CURRENT" |
"CONREF" | "IMPLIED"))</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>FIXED</DT>
<DD>means the attribute is a fixed attribute.</DD>
<DT>REQUIRED</DT>
<DD>means the attribute is a required attribute.</DD>
<DT>CURRENT</DT>
<DD>means the attribute is a current attribute.</DD>
<DT>CONREF</DT>
<DD>means the attribute is a content reference attribute.</DD>
<DT>IMPLIED</DT>
<DD>means the attribute is an impliable attribute.

<NT>Specifying an empty literal is not equivalent to
specifying "IMPLIED".</NT></DD></DL></P>
<P>If an attribute value is specified in this parameter,
it must conform to the syntactic requirements specified in 7.9.4.1.</P>
<NT>Further testing of general entity name,
<REV REFID="AMEND1">general entity name list,</REV>
and notation values is performed when the default value is used
in an attribute specification.</NT>
<P>If the
<HPV>declared value</HPV> is "ID",
the
<HPV>default value</HPV> must be
"IMPLIED" or "REQUIRED".</P>
<P>"CONREF" cannot be declared for an element whose

<HPV>declared content</HPV> is "EMPTY".</P>
<H4>Quantities</H4>
<LOSTDATA></LOSTDATA>
<P>"CONREF", "REQUIRED", and "IMPLIED"
have normalized lengths of zero.</P>
<H4>Capacities</H4>
<LOSTDATA></LOSTDATA>
<P>In calculating "ATTCHCAP" requirements,
the default value of a current attribute is given the length of
the longest value specified for the attribute in the document.</P>
<H2>Notation Declaration</H2>
<PROD>[148] notation declaration =

<HPD>mdo</HPD>, "NOTATION",

<HPV>ps</HPV>+,
<HPV>notation name</HPV>,

<HPV>ps</HPV>+,
<HPV>notation identifier</HPV>,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[149] notation identifier =
<HPV>external identifier</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>notation name</HPV> cannot be specified on another

<HPV>notation declaration</HPV> in the same document type definition.</P>
<P>If a
<HPV>notation identifier</HPV> includes a
<HPV>public identifier</HPV>
and "FORMAL YES" is specified on the
<HPV>SGML declaration</HPV>,
the
<HPV>public text class</HPV> must be "NOTATION".
<REV REFID="AMEND1">
<H3>Data Attributes</H3>
<LOSTDATA></LOSTDATA>
<NT>Data attributes are defined for a data content notation.
Values can be specified for them on the entity declarations
for data entities conforming to the notation.</NT>
<P>The
<HPV>declared value</HPV> of a data attribute cannot be
"ENTITY", "ENTITIES", "ID",
"IDREF", "IDREFS", or "NOTATION".</P>
<P>"CURRENT" or "CONREF"
cannot be specified for a data attribute.</P>
<H4>Associated Notation Name</H4>
<PROD>[149.1] associated notation name =

<HPD>rni</HPD>, "NOTATION",

<HPV>ps</HPV>+, (
<HPV>notation name</HPV> |
<HPV>name group</HPV>)</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>NOTATION</DT>
<DD>means the attributes being defined are data attributes.</DD></DL></P>
<P>Each
<HPV>name</HPV> in the
<HPV>name group</HPV> must be a
<HPV>notation name</HPV>
defined in the same document type definition
in which this attribute definition list occurs,
and not specified for any other attribute definition list.
It need not have been defined prior to this declaration,
but must be defined prior to a reference to an entity
for which it was declared to be the notation.</P>
<H4>Data Attribute Specification</H4>
<PROD>[149.2] data attribute specification =

<HPV>ps</HPV>+,
<HPD>dso</HPD>,

<HPV>attribute specification list</HPV>,

<HPV>s</HPV>*,
<HPD>dsc</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>The validity of a data
<HPV>attribute specification list</HPV> is determined
by the attribute definition list associated with the data content notation.
The attribute definition list must have been declared
prior to this declaration.</P>
<P>The
<HPV>data attribute specification</HPV> must be omitted if its

<HPV>attribute specification list</HPV> is empty.</P></H4></H3></REV></P>
<H2>Short Reference Mapping Declaration</H2>
<PROD>[150] short reference mapping declaration =

<HPD>mdo</HPD>, "SHORTREF",

<HPV>ps</HPV>+,
<HPV>map name</HPV>,
(
<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>,

<HPV>ps</HPV>+,
<HPV>name</HPV>)+,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[151] map name =
<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>map name</HPV> cannot be specified on another

<HPV>short reference mapping declaration</HPV>
in the same document type definition.</P>
<P>The
<HPV>interpreted parameter literal</HPV> is a
<HPV>short reference</HPV> delimiter
that is mapped to the
<HPV>name</HPV> of a general entity that is defined
in the same document type definition.</P>
<NT>A general entity is required because
the short reference will be replaced by a named entity reference
if the document is sent to a system that does not support short references,
and parameter entity references are not permitted in
<HPV>content</HPV>.</NT>
<P>A short reference delimiter can be mapped only once in a

<HPV>short reference mapping declaration</HPV>.</P>
<P>If a
<HPV>short reference</HPV> delimiter is not specified
it is considered to be mapped to nothing.</P>
<H2>Short Reference Use Declaration</H2>
<PROD>[152] short reference use declaration =

<HPD>mdo</HPD>, "USEMAP",

<HPV>ps</HPV>+,
<HPV>map specification</HPV>,
(
<HPV>ps</HPV>+,
<HPV>associated element type</HPV>)?,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[153] map specification =

<HPV>map name</HPV> | (
<HPD>rni</HPD>, "EMPTY")</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>EMPTY</DT>
<DD>means the map is the empty map.</DD></DL></P>
<H3>Use in Document Type Declaration</H3>
<LOSTDATA></LOSTDATA>
<P>If the declaration occurs in a
<HPV>document type declaration</HPV>,
the
<HPV>associated element type</HPV> must be specified.
The named map will become the current map
whenever an element of an associated type becomes the current element.</P>
<P>The
<HPV>map name</HPV> must be defined on a

<HPV>short reference mapping declaration</HPV>
in the same
<HPV>document type declaration</HPV>.</P>
<NT>It need not have been defined prior to this declaration,
but must be defined prior to becoming the current map.</NT>
<P>Specifying an associated element type
that is already associated with a map
is not an error,
but is ignored.</P>
<H3>Use in Document Instance</H3>
<LOSTDATA></LOSTDATA>
<P>If the declaration occurs in a
<HPV>document instance</HPV>,
an
<HPV>associated element type</HPV> cannot be specified.
The map becomes the current map for this instance of the current element.</P>
<P>The
<HPV>map name</HPV> must have been defined on a

<HPV>short reference mapping declaration</HPV>
in the document type definition to which the instance conforms.</P>
<H3>Current Map</H3>
<LOSTDATA></LOSTDATA>
<P>A map is the current map as long its associated element is the current element.
It can become superceded for an instance of the element:
either temporarily by a subelement becoming the current element,
or permanently by a
<HPV>short reference use declaration</HPV>
occurring in an instance of the element.</P>
<P>If an element type has no associated short reference map,
the current map for an instance of the element
is the map that is current when the instance begins.
If the element is a document element,
the current map will be the empty map.</P>
<H1>Markup Declarations: Link Process Definitions</H1>
<LOSTDATA></LOSTDATA>
<H2>Link Type Declaration</H2>
<PROD>[154] link type declaration =

<HPD>mdo</HPD>, "LINKTYPE",

<HPV>ps</HPV>+,
<HPV>link type name</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+,</REV>
(
<HPV>simple link specification</HPV> |

<HPV>implicit link specification</HPV> |

<HPV>explicit link specification</HPV>),
(
<HPV>ps</HPV>+,
<HPV>external identifier</HPV>)?,
(
<HPV>ps+</HPV>,
<HPD>dso</HPD>,

<HPV>link type declaration subset</HPV>,
<HPD>dsc</HPD>)?,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[155] link type name =
<HPV>name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>link type name</HPV> must be different
from any other
<HPV>link type name</HPV>
or
<HPV>document type name</HPV> in the same
<HPV>prolog</HPV>.</P>
<P>The
<HPV>external identifier</HPV> points to an entity that is
referenced at the end of the declaration subset
and is considered to be part (or all) of it.
The effective link process definition is the combination of
the declarations entered in the subset and the external ones.</P>
<NT>A parameter entity declaration in the subset will have priority
over another declaration for that entity in the external entity,
as the external entity is parsed later.</NT>
<REV REFID="AMEND1">
<P>An
<HPC>Ee</HPC> or
<HPV>parameter entity reference</HPV>
cannot occur in a
<HPV>link type declaration</HPV>,
except within the
<HPV>link type declaration subset</HPV>.</P></REV>
<H3>Simple Link Specification</H3>
<PROD>[156] simple link specification =

<HPD>rni</HPD>, "SIMPLE",

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPD>rni</HPD>, "IMPLIED"</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>SIMPLE</DT>
<DD>means the link is a simple link.</DD>
<DT>IMPLIED</DT>
<DD>means the
<HPV>result document type</HPV> is implied by the application.</DD></DL></P>
<P>If a simple link is specified, "SIMPLE YES" must be specified
on the
<HPV>link type features</HPV> parameter of the
<HPV>SGML declaration</HPV>.</P>
<P>The source document type is the base document type.
<REV REFID="AMEND1">
<H4>Limits</H4>
<LOSTDATA></LOSTDATA>
<P>The number of simple link processes that can be active simultaneously
cannot exceed the quantity specified for "SIMPLE"
on the
<HPV>link type features</HPV> parameter of the
<HPV>SGML declaration</HPV>.</P></H4></REV></P>
<H3>Implicit Link Specification</H3>
<PROD>[157] implicit link specification =

<HPV>source document type name</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPD>rni</HPD>, "IMPLIED"</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>IMPLIED</DT>
<DD>means the
<HPV>result document type</HPV> is implied by the application.</DD></DL></P>
<P>If an implicit link is specified, "IMPLICIT YES" must be specified
on the
<HPV>link type features</HPV> parameter of the
<HPV>SGML declaration</HPV>.</P>
<P>The
<HPV>source document type name</HPV> must be the base document type,
<REV REFID="AMEND1">or another document type that is the last result document type
in a chain of processes.</REV></P>
<H3>Explicit Link Specification</H3>
<PROD>[158] explicit link specification =

<HPV>source document type name</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPV>result document type name</HPV></REV></PROD>
<PROD>[159] source document type name =

<HPV>document type name</HPV></PROD>
<PROD>[160] result document type name =

<HPV>document type name</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>If an explicit link is specified, "EXPLICIT YES" must be specified
on the
<HPV>link type features</HPV> parameter of the
<HPV>SGML declaration</HPV>.</P>
<P>The
<HPV>source document type name</HPV> must be the base document type,
or another document type that is a result document type
in a chain of processes.</P>
<P>Each
<HPV>document type name</HPV> must previously have been specified
on a
<HPV>document type declaration</HPV> in the same
<HPV>prolog</HPV>.</P>
<H4>Limits</H4>
<LOSTDATA></LOSTDATA>
<P>The number of link processes in the longest chain
cannot exceed the quantity specified for "EXPLICIT"
on the
<HPV>link type features</HPV> parameter of the
<HPV>SGML declaration</HPV>.</P>
<H3>Link Type Declaration Subset</H3>
<PROD>[161] link type declaration subset =

<REV REFID="AMEND1">(
<HPV>link attribute set</HPV> |
<HPV>link set declaration</HPV>)*,

<HPV>ID link set declaration</HPV>?,
(
<HPV>link attribute set</HPV> |
<HPV>link set declaration</HPV>)*</REV></PROD>
<PROD>[162] link attribute set =
(
<HPV>attribute definition list declaration</HPV> |

<HPV>entity set</HPV>)*</PROD>
<REV REFID="AMEND1">
<H4>Entities</H4>
<LOSTDATA></LOSTDATA></REV>
<LOSTDATA></LOSTDATA>
<P>When this link type is active, the entity declarations are treated as if
they occurred
<REV REFID="AMEND1">at the start of the source document type declaration subset,
but after the entity declarations
of any preceding active link type declarations.</REV></P>
<P>A link type declaration can contain parameter entity references to entities
defined in the source document type declaration,
as well as in its own declaration subset.</P>
<H4>Link Attributes</H4>
<LOSTDATA></LOSTDATA>
<P>An associated element type of an attribute definition list
must be a source element type.</P>
<P>The
<HPV>declared value</HPV> of a link attribute cannot be
"ID", "IDREF", "IDREFS", or "NOTATION".</P>
<P>
<REV REFID="AMEND1">"CURRENT" or "CONREF"</REV>cannot be specified for a link attribute.</P>
<H4>Simple Link</H4>
<LOSTDATA></LOSTDATA>
<P>If the declaration defines a simple link,
the declaration subset must consist solely of a
<HPV>link attribute set</HPV>
that contains no more than one
<HPV>attribute definition list declaration</HPV>.
The list must be associated with the base document element type,
and can define only fixed attributes.</P>
<H2>Link Set Declaration</H2>
<PROD>[163] link set declaration =

<HPD>mdo</HPD>, "LINK",

<HPV>ps</HPV>+,
<HPV>link set name</HPV>,

<REV REFID="AMEND1">(
<HPV>ps</HPV>+,
<HPV>link rule</HPV>)+,</REV>

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<REV REFID="AMEND1">
<PROD>[163.1] link rule =

<HPV>source element specification</HPV> |

<HPV>explicit link rule</HPV></PROD></REV>
<PROD>[164] link set name =

<REV REFID="AMEND1">
<HPV>name</HPV> | (
<HPD>rni</HPD>, "INITIAL")</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>
<REV REFID="AMEND1">where:

<DL TERMHI="2" TSIZE="11">
<DT>INITIAL</DT>
<DD>identifies the link set that is current when the document instance begins.</DD></DL></REV></P>
<P>The
<HPV>link set name</HPV> cannot be specified on another

<HPV>link set declaration</HPV>
<REV REFID="AMEND1">in the same link type declaration.</REV>
<REV REFID="AMEND1">
<P>
<Q>#INITIAL</Q> must be specified for only one
<HPV>link set declaration</HPV>
in a
<HPV>link type declaration subset</HPV>.</P>
<P>If an implicit link is specified,
a
<HPV>link rule</HPV> must be a
<HPV>source element specification</HPV>;
if an explicit link is specified,
it must be an
<HPV>explicit link rule</HPV>.</P></REV></P>
<H3>Source Element Specification</H3>
<PROD>[165] source element specification =

<HPV>associated element type</HPV>,

<REV REFID="AMEND1">(
<HPV>ps</HPV>+,
<HPD>rni</HPD>, "USELINK",

<HPV>ps</HPV>+,
(
<HPV>link set name</HPV> | (
<HPD>rni</HPD>, "EMPTY")))?,
(
<HPV>ps</HPV>+,
<HPD>rni</HPD>, "POSTLINK",

<HPV>ps</HPV>+,

<HPV>link set specification</HPV>)?,</REV>

<HPV>link attribute specification</HPV>?</PROD>
<PROD>[166] link attribute specification =

<HPV>ps</HPV>+,

<HPD>dso</HPD>,

<HPV>attribute specification list</HPV>,

<REV REFID="AMEND1">
<HPV>s</HPV>*,
<HPD>dsc</HPD></REV></PROD>
<REV REFID="AMEND1">
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>USELINK</DT>
<DD>means that the specified link set will become the current link set
when an element of an associated type becomes the current element.

<NT>The
<Q>#USELINK</Q> parameter acts like a link set use declaration
that occurs immediately after the start-tag;
that is, it affects the subelements of an element.
It has no effect if an element is empty.</NT></DD>
<DT>POSTLINK</DT>
<DD>means that the specified link set will become the current link set
when an element of an associated type ceases to be the current element.

<NT>The
<Q>#POSTLINK</Q> parameter acts like a link set use declaration
that occurs immediately after the end-tag
(or after the start-tag if the element is empty and has no end-tag);
that is, it affects succeeding elements within the same containing element.</NT></DD></DL></P>
<P>The specified link set must be defined by a
<HPV>link set declaration</HPV>
in the same
<HPV>link type declaration</HPV>.</P>
<P>An element type can be an
<HPV>associated element type</HPV>
in only one link rule in a link set,
unless in each such link rule there is a
<HPV>link attribute specification</HPV>.</P>
<NT>An application must be able to determine from the link attributes
which rule applies to a given instance of the element type.
For example, the application could define a
<Q>usage</Q> attribute
whose value is an expression that tests source attribute values
and the state of processing;
the rule would apply if the expression were true.</NT></REV>
<LOSTDATA></LOSTDATA>
<P>The validity of a link
<HPV>attribute specification list</HPV> is determined
by the attribute definition list
associated with the source element type
in the link type declaration subset.
<REV REFID="AMEND1">The attribute definition list must have been declared
prior to this declaration.</REV>
All element types associated with an attribute specification
must be associated with the same definition.</P>
<P>The
<HPV>link attribute specification</HPV> must be omitted if
its
<HPV>attribute specification list</HPV> is empty.
<REV REFID="AMEND1">
<H3>Explicit Link Rule</H3>
<PROD>[166.1] explicit link rule =
(
<HPV>source element specification</HPV>,

<HPV>ps</HPV>+,
<HPV>result element specification</HPV>) |
(
<HPV>source element specification</HPV>,

<HPV>ps</HPV>+,
<HPD>rni</HPD>, "IMPLIED") |
(
<HPD>rni</HPD>, "IMPLIED",

<HPV>ps</HPV>+,
<HPV>result element specification</HPV>)</PROD>
<LOSTDATA></LOSTDATA></H3></REV>
<PROD>[167] result element specification =

<REV REFID="AMEND1">
<HPV>generic identifier</HPV>,

<HPV>result attribute specification</HPV>?</REV></PROD>
<PROD>[168] result attribute specification =

<HPV>ps</HPV>+,

<HPD>dso</HPD>,

<HPV>attribute specification list</HPV>,

<REV REFID="AMEND1">
<HPV>s</HPV>*,
<HPD>dsc</HPD></REV></PROD></P>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>IMPLIED</DT>
<DD>
<REV REFID="AMEND1">means the source or result element is implied by the application.</REV></DD></DL>
<REV REFID="AMEND1">
<P>
<Q>#IMPLIED</Q> can be linked to a given result element type
only once in a link set.</P></REV></P>
<P>The validity of the result

<HPV>attribute specification list</HPV> is determined
by the
<HPV>attribute definition list</HPV>
associated with the result element
in the result element document type declaration.</P>
<P>The
<HPV>result attribute specification</HPV> must be omitted if
its
<HPV>attribute specification list</HPV> is empty.
<REV REFID="AMEND1">
<H3>ID Link Set Declaration</H3>
<PROD>[168.1] ID link set declaration =

<HPD>mdo</HPD>, "IDLINK",
(
<HPV>ps</HPV>+,
<HPV>name</HPV>,

<HPV>ps</HPV>+,
<HPV>link rule</HPV>)+,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>name</HPV> should be the unique identifier of a source element.
The corresponding
<HPV>link rule</HPV> will apply to that element
regardless of the current link set.
The
<HPV>associated element type</HPV> of the
<HPV>link rule</HPV>
must be that of the identified source element.</P>
<P>A
<HPV>name</HPV> can be associated with only one
<HPV>link rule</HPV> in an ID link set,
unless in each such
<HPV>link rule</HPV> there is a
<HPV>link attribute specification</HPV>.</P></H3></REV></P>
<H2>Link Set Use Declaration</H2>
<PROD>[169] link set use declaration =

<HPD>mdo</HPD>, "USELINK",

<HPV>ps</HPV>+,
<HPV>link set specification</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPV>link type name</HPV>,</REV>

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<PROD>[170] link set specification =

<HPV>link set name</HPV> |
(
<HPD>rni</HPD>, "EMPTY") |

<REV REFID="AMEND1">(
<HPD>rni</HPD>, "RESTORE")</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>EMPTY</DT>
<DD>means the link set is the empty link set.
<REV REFID="AMEND1">
<DT>RESTORE</DT>
<DD>means the link set is that associated with the current element
or, if there is none,
the link set that was current when the current element began.</DD></REV></DD></DL></P>
<P>The link set becomes the current link set for this instance
of the current element.
<REV REFID="AMEND1">
<NT>As an aid to revision of the document, a declaration such as:

<XMP><!USELINK #RESTORE linktype></XMP>
should be specified at the point where the link set
activated by a
<HPV>link set use declaration</HPV>
is no longer required.</NT></REV></P>
<P>The
<HPV>link type name</HPV> must be that of the
<HPV>link type declaration</HPV>
in which the link set was defined.
<REV REFID="AMEND1">If the
<HPV>link type name</HPV> is not an active link type,
the declaration is ignored.</REV>
<REV REFID="AMEND1">
<H2>Current Link Set</H2>
<LOSTDATA></LOSTDATA></H2></REV></P>
<P>A link set is the current link set
as long as its element is the current element.
It can become superceded for an instance of the element:
either temporarily by a subelement becoming the current element,
or permanently by a
<HPV>link set use declaration</HPV>
occurring in an instance of the element.</P>
<P>If an element type has no associated link set,
the current link set for an instance of the element
is the link set that is current when the instance begins.
If the element is a document element,
<REV REFID="AMEND1">the current link set is the initial link set.</REV></P>
<H1>SGML Declaration</H1>
<PROD>[171] sgml declaration =

<HPD>mdo</HPD>, "SGML",

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPV>minimum literal</HPV>,</REV>

<HPV>ps</HPV>+,
<HPV>document character set</HPV>,

<HPV>ps</HPV>+,
<HPV>capacity set</HPV>,

<HPV>ps</HPV>+,
<HPV>concrete syntax scope</HPV>,

<HPV>ps</HPV>+,
<HPV>concrete syntax</HPV>,

<HPV>ps</HPV>+,
<HPV>feature use</HPV>,

<HPV>ps</HPV>+,
<HPV>application-specific information</HPV>,

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<REV REFID="AMEND1">
<P>The
<HPV>minimum data</HPV> of the
<HPV>minimum literal</HPV> must be

<Q>ISO 8879:1986</Q>.</P></REV>
<LOSTDATA></LOSTDATA>
<P>The reference concrete syntax must be used in the
<HPV>SGML declaration</HPV>,
regardless of the concrete syntax used in the remainder of the document.</P>
<P>Only markup characters (in the reference concrete syntax)
and
<HPV>minimum data</HPV> characters can be used in the parameters and comments,
although the replacement text of a character reference
could be an SGML character other than a markup or minimum data character.

<NOTEL>
<LI>The
<HPV>SGML declaration</HPV> is intended for human consumption
(in printed form!)
as well as for machine processing,
as it enables the recipient of a document to determine
whether a system can process it
<Q>as is</Q>,
whether character translation or other algorithmic conversion is needed
(for example,
if document markup features of a different delimiter set were used),
or whether conversion that could require manual intervention is needed
(for example,
if document type features or a different quantity set were used).</LI>
<LI>A character reference such as
<Q>&amp;#222;</Q> is valid because the reference
consists solely of markup and minimum data characters,
even though the replacement text does not.</LI>
<LI>No entity references can occur in a SGML declaration
(because no entities could have been declared).</LI></NOTEL></P>
<H2>Document Character Set</H2>
<PROD>[172] document character set =
"CHARSET" ,

<HPV>ps</HPV>+,
<HPV>character set description</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The document character set must include a coded representation,
as a single bit combination,
for each significant SGML character.</P>
<NT>If the document uses two concrete syntaxes,
the markup characters of both are significant SGML characters.</NT>
<P>As part of the translation of a document to a new character set,
the character numbers in this parameter
and any numeric character references in the document
must be changed.</P>
<NT>It is recognized that the recipient of a document must be able
to translate it to his system character set
before the document can be processed by machine.
There are two basic approaches to communicating this information:

<OL>
<LI>If the character set is standard, registered,
or otherwise capable of being referenced by an identifying name or number,
that identifier can be communicated to the recipient of the document.
The communication must not necessarily occur outside of the document;
for example, in a field of the document interchange data stream,
or via other (probably non-electronic) media.</LI>
<LI>For other character sets, a human-readable copy of the SGML declaration
will provide sufficient information.</LI></OL></NT>
<H3>Character Set Description</H3>
<PROD>[173] character set description =

<REV REFID="AMEND1">
<HPV>base character set</HPV>,

<HPV>ps</HPV>+,
<HPV>described character set portion</HPV>,
(
<HPV>ps</HPV>+,
<HPV>base character set</HPV>,

<HPV>ps</HPV>+,
<HPV>described character set portion</HPV>)*</REV></PROD>
<LOSTDATA></LOSTDATA>
<P>The described character set portions must collectively
describe each character number in the described character set
once and only once.</P>
<H4>Base Character Set</H4>
<PROD>[174] base character set =
"BASESET" ,

<HPV>ps</HPV>+,
<HPV>public identifier</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>public identifier</HPV> is a human-readable identifier
of the
<HPV>base character set</HPV>.</P>
<NT>For example, a standard or registered name or number,
or other designation that will be understood
by the expected recipients of the document.</NT>
<P>If "FORMAL YES" is specified on the
<HPV>other features</HPV> parameter,
the
<HPV>public identifier</HPV> must be a
<HPV>formal public identifier</HPV>
with a
<HPV>public text class</HPV> of "CHARSET".</P>
<H4>Described Character Set Portion</H4>
<PROD>[175] described character set portion =
"DESCSET" ,
(
<HPV>ps</HPV>+,
<HPV>character description</HPV>)+</PROD>
<PROD>[176] character description =

<HPV>described set character number</HPV>,

<HPV>ps</HPV>+,
<HPV>number of characters</HPV>,

<HPV>ps</HPV>+,
(
<HPV>base set character number</HPV> |

<HPV>minimum literal</HPV> | "UNUSED")</PROD>
<PROD>[177] described set character number =

<HPV>character number</HPV></PROD>
<PROD>[178] base set character number =

<HPV>character number</HPV></PROD>
<PROD>[179] number of characters =
<HPV>number</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>UNUSED</DT>
<DD>means that no meaning is assigned
to the specified character numbers in the described set.</DD></DL></P>
<P>The specified
<HPV>number of characters</HPV> in the described character set,
beginning with the specified
<HPV>described set character number</HPV>
are assigned meanings as follows:

<OL>
<LI>If a
<HPV>base character number</HPV> is specified,
the meanings are those of the corresponding characters
in the
<HPV>base character set</HPV>,
beginning with the specified
<HPV>base set character number</HPV>.

<NT>If a base set character number is unused,
no meaning is assigned to the corresponding described set character number.</NT></LI>
<LI>If a
<HPV>minimum literal</HPV> is specified,
the meaning or meanings are as described in the literal.

<NT>A
<HPV>minimum literal</HPV> should be specified only if no character
in the
<HPV>base character set</HPV> has the desired meaning.</NT></LI>
<LI>If "UNUSED" is specified,
no meanings are assigned.</LI></OL></P>
<H3>Non-SGML Character Identification</H3>
<LOSTDATA></LOSTDATA>
<P>Each
<HPV>character number</HPV> to which no meaning is assigned by the

<HPV>character set description</HPV> is added to
<HPT>NONSGML</HPT>,
thereby identifying it as a non-SGML character.</P>
<NT>After receipt and translation of a document,
the non-SGML characters may be different
because the new document character set may map control characters
to different coded representation.</NT>
<P>A shunned character must be identified as a non-SGML character,
unless it is a significant SGML character.

<NOTEL>
<LI>For example, in figure 8, characters numbered 9, 10, and 13,
which are shunned characters,
are nevertheless not assigned as non-SGML characters
because they are functions characters.</LI>
<LI>If the document uses two concrete syntaxes,
the shunned characters of both are subject to this requirement.</LI></NOTEL></P>
<H2>Capacity Set</H2>
<PROD>[180] capacity set =
"CAPACITY" ,

<HPV>ps</HPV>+,
(("PUBLIC",
<HPV>ps</HPV>+,
<HPV>public identifier</HPV>) |
("SGMLREF",
(
<HPV>ps</HPV>+,
<HPV>name</HPV>,

<HPV>ps</HPV>+,
<HPV>number</HPV>)+))</PROD>
<LOSTDATA></LOSTDATA>
<P>The specified
<HPV>name</HPV> is a name given to a capacity in figure 5.
The capacity is assigned the value indicated by the specified
<HPV>number</HPV>.</P>
<P>The reference capacity set value is used for any capacity
for which no replacement is assigned by this parameter.</P>
<NT>The "SGMLREF" keyword which is required
(and therefore redundant)
when a public identifier is not used,
is a reminder of this rule for human readers of the SGML declaration.</NT>
<P>The capacity values must express limits that are not exceeded by the document.
They must be sufficient for the greatest capacity requirement
among the possible sets of concurrent instances or chain of link processes
that could be processed at once.</P>
<P>The value assigned to "TOTALCAP"
must equal or exceed the largest individual capacity.</P>
<P>If "FORMAL YES" is specified on the
<HPV>other features</HPV> parameter,
the
<HPV>public identifier</HPV> must be a
<HPV>formal public identifier</HPV>
with a
<HPV>public text class</HPV> of "CAPACITY".</P>

<TABLE TYPE="TBL4B">
<TTITLE>Reference Capacity Set</TTITLE>
<TBODY>
<ROW><C><P>Name</P></C><C><P>Value</P></C><C><P>Points</P></C><C><P>Objects for which capacity points are counted</P></C></ROW>
<ROW><C><P>TOTALCAP</P></C><C><P>35000</P></C><C><P>(total)</P></C><C><P>Grand total of individual capacity points</P></C></ROW>
<ROW><C><P>ENTCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Entity defined.</P></C></ROW>
<ROW><C><P>ENTCHCAP</P></C><C><P>35000</P></C><C><P>1</P></C><C><P>Character of entity text.</P></C></ROW>
<ROW><C><P>ELEMCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Element defined.</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>GRPCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Content token at any level of a content model
(a data tag group is three tokens).</P></C>
</REV>
</ROW>
<ROW><C><P>EXGRPCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Exclusion or inclusion exceptions group.</P></C></ROW>
<ROW><C><P>EXNMCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Name in an exclusion or inclusion exceptions group.</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>ATTCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C>
<C><P>
Attribute defined, plus NAMELEN for each occurrence (whether or not the attribute is specified)
in a link set declaration
<SL>
<LI>
of an element type associated with the definition,
</LI>
</SL>
or, in an entity declaration,
<SL>
<LI>
of a notation name associated with the definition.
</LI>
</SL>
</P></C>
</REV>
</ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>ATTCHCAP</P></C><C><P>1</P></C><C><P>NAMELEN</P></C>
<C><P>
Character of normalized length of an attribute value defined as the default value, or explicitely defined
(not defaulted)
</P></C>
</REV>
</ROW>
<ROW><C><P>AVGRPCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C>
<C><P>
Token defined in an attribute value name group or name token group
</P></C></ROW>
<ROW><C><P>NOTCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Data content notation defined.</P></C></ROW>
<ROW><C><P>NOTCHCAP</P></C><C><P>35000</P></C><C><P>1</P></C><C><P>Character in a notation identifier.</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>IDCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>ID attribute specified.</P></C>
</REV>
</ROW>
<ROW><C><P>IDREFCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>IDREF attribute specified (explicitely or defaulted).</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>MAPCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C>
<C><P>
Short reference map declared, plus, for each map declared,
NAMELEN for each short reference delimiter in the concrete syntax
(whether or not the delimiter is specified in the map).
</P></C>
</REV>
</ROW>
<ROW><C><P>LKSETCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Link types or link sets defined.</P></C></ROW>
<ROW><C><P>LKNMCAP</P></C><C><P>35000</P></C><C><P>NAMELEN</P></C><C><P>Document type or element in a link type or link set declaration.</P></C></ROW>
</TBODY>
</TABLE>
<H2>Concrete Syntax Scope</H2>
<LOSTDATA></LOSTDATA>
<P>This parameter specifies
whether a declared concrete syntax must be used for the entire document,
or whether the reference concrete syntax can be used in the prologs.
<PROD>[181] concrete syntax scope =
"SCOPE" ,

<HPV>ps</HPV>+, ("DOCUMENT" | "INSTANCE")</PROD></P>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>DOCUMENT</DT>
<DD>means the declared concrete syntax is used throughout the document.</DD>
<DT>INSTANCE</DT>
<DD>means the reference concrete syntax is used in prologs and
the declared concrete syntax is used in document instance sets.</DD></DL></P>
<P>If "INSTANCE" is specified,
the declared concrete syntax must meet the following requirements:

<OL>
<LI>the syntax-reference character set must be the same as
that of the reference concrete syntax;</LI>
<LI>the significant SGML characters must be such
that the start of a document instance set
is always distinguishable from the end of its prolog;
and</LI>
<LI>the quantity set values must equal or exceed
those of the reference quantity set.</LI></OL></P>
<H2>Concrete Syntax</H2>
<PROD>[182] concrete syntax =
"SYNTAX" ,

<HPV>ps</HPV>+,
(
<HPV>public concrete syntax</HPV> |
(
<HPV>shunned character number identification</HPV>,

<HPV>ps</HPV>+,
<HPV>syntax reference character set</HPV>,

<HPV>ps</HPV>+,
<HPV>function character identification</HPV>,

<HPV>ps</HPV>+,
<HPV>naming rules</HPV>,

<HPV>ps</HPV>+,
<HPV>delimiter set</HPV>,

<HPV>ps</HPV>+,
<HPV>reserved name use</HPV>,

<HPV>ps</HPV>+,
<HPV>quantity set</HPV>))</PROD>
<LOSTDATA></LOSTDATA>
<P>The reference concrete syntax or core concrete syntax should be used
unless a variant concrete syntax is necessitated by such requirements as
the keyboard, display capabilities,
or characteristics of the national language.</P>
<H3>Public Concrete Syntax</H3>
<PROD>[183] public concrete syntax =
"PUBLIC" ,

<HPV>ps</HPV>+,
<HPV>public identifier</HPV>,
(
<HPV>ps</HPV>+, "SWITCHES",
(
<HPV>ps</HPV>+,
<HPV>character number</HPV>,

<HPV>ps</HPV>+,
<HPV>character number</HPV>)+)?</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>SWITCHES</DT>
<DD>means that markup characters in the specified concrete syntax
have been switched.</DD></DL></P>
<P>The pairs of character numbers are in the

<HPV>syntax-reference character set</HPV>
of the
<HPV>public concrete syntax</HPV>.
The first of each pair is a markup character
<REV REFID="AMEND1">other than a
<HPC>Digit</HPC>,
<HPC>LC Letter</HPC> or
<HPC>UC Letter</HPC></REV>
in the identified concrete syntax and
the second is a character
<REV REFID="AMEND1">other than a
<HPC>Digit</HPC>,
<HPC>LC Letter</HPC> or
<HPC>UC Letter</HPC></REV>
that substitutes for it in every instance in which the first character was used.</P>
<NT>The concrete syntax that results from the switches
must meet all the usual requirements,
just as if it had been declared explicitely.</NT>
<P>If "FORMAL YES" is specified on the
<HPV>other features</HPV> parameter,
the
<HPV>public identifier</HPV> must be a
<HPV>formal public identifier</HPV>
with a
<HPV>public text class</HPV> of "SYNTAX".</P>
<H3>Shunned Character Number Identification</H3>
<PROD>[184] shunned character number identification =
"SHUNCHAR" ,

<HPV>ps</HPV>+, ("NONE" |
(("CONTROLS" |
<HPV>character number</HPV>),
(
<HPV>ps</HPV>+,
<HPV>character number</HPV>)*))</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>NONE</DT>
<DD>means there are no shunned character numbers.</DD>
<DT>CONTROLS</DT>
<DD>means that any character number
<REV REFID="AMEND1">that the system character set</REV>
considers to be the coded representation
of a control character, and not a graphic character,
is a shunned character.</DD></DL></P>
<P>Each specified
<HPV>character number</HPV> is identified
as a shunned character number.</P>
<NT>Character numbers in this parameter need not (and should not) be changed
when a document is translated to another character set.</NT>
<H3>Syntax-Reference Character Set</H3>
<PROD>[185] syntax-reference character set =

<HPV>character set description</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>The syntax-reference character set must include a coded representation,
as a single bit combination,
of each significant SGML character.</P>
<H3>Function Character Identification</H3>
<PROD>[186] function character identification =
"FUNCTION" ,

<HPV>ps</HPV>+, "RE",
<HPV>ps</HPV>+,
<HPV>character number</HPV>,

<HPV>ps</HPV>+, "RS",
<HPV>ps</HPV>+,
<HPV>character number</HPV>,

<HPV>ps</HPV>+, "SPACE",
<HPV>ps</HPV>+,
<HPV>character number</HPV>,
(
<HPV>ps</HPV>+,
<HPV>added function</HPV>,

<HPV>ps</HPV>+,
<HPV>function class</HPV>,

<HPV>ps</HPV>+,
<HPV>character number</HPV>)*</PROD>
<PROD>[187] added function =

<HPV>name</HPV></PROD>
<PROD>[188] function class =
"FUNCHAR" |
"MSICHAR" | "MSOCHAR" | "MSSCHAR" |
"SEPCHAR"</PROD>
<LOSTDATA></LOSTDATA>
<P>where the keywords identify the
<HPV>added function</HPV>, as follows:

<DL TERMHI="2" TSIZE="11">
<DT>FUNCHAR</DT>
<DD>means an inert function character.</DD>
<DT>SEPCHAR</DT>
<DD>means a separator character.</DD>
<DT>MSOCHAR</DT>
<DD>means a markup-scan-out character.</DD>
<DT>MSICHAR</DT>
<DD>means a markup-scan-in character.</DD>
<DT>MSSCHAR</DT>
<DD>means a markup-scan-suppress character.</DD></DL></P>
<P>The character with the specified
<HPV>character number</HPV>
in the
<HPV>syntax-reference character set</HPV> is assigned to the function.</P>
<P>A character can be assigned to only one function.</P>
<P>An
<HPV>added function</HPV> cannot be "RE", "RS",
"SPACE", or another
<HPV>added function</HPV>.</P>
<P>"MSICHAR" must be specified for at least one
<HPV>added function</HPV>
if "MSOCHAR" is specified for an
<HPV>added function</HPV>.</P>
<NT>When code extension is used,
shift characters could be assigned to markup suppression
to avoid false delimiter recognition,
but only by sacrificing the ability to use entity references
to obtain device independence (see clause E.3).</NT>
<H3>Naming Rules</H3>
<PROD>[189] naming rules =
"NAMING" ,

<HPV>ps</HPV>+, "LCNMSTRT",

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>,

<HPV>ps</HPV>+, "UCNMSTRT",

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>,

<HPV>ps</HPV>+, "LCNMCHAR",

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>,

<HPV>ps</HPV>+, "UCNMCHAR",

<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>,

<HPV>ps</HPV>+, "NAMECASE",

<HPV>ps</HPV>+, "GENERAL",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "ENTITY",
<HPV>ps</HPV>+, ("NO" | "YES")</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="13">
<DT>LCNMSTRT</DT>
<DD>means each
<HPV>character</HPV> in the literal (if any) is added
to
<HPT>LCNMSTRT</HPT>.</DD>
<DT>UCNMSTRT</DT>
<DD>Each
<HPV>character</HPV> in the literal (if any) is added
to
<HPT>UCNMSTRT</HPT>
as the associated upper-case form of the character
in the corresponding position of
<HPT>LCNMSTRT</HPT>.</DD>
<DT>LCNMCHAR</DT>
<DD>means each
<HPV>character</HPV> in the literal (if any) is added
to
<HPT>LCNMCHAR</HPT>.</DD>
<DT>UCNMCHAR</DT>
<DD>Each
<HPV>character</HPV> in the literal (if any) is added
to
<HPT>UCNMCHAR</HPT>
as the associated upper-case form of the character
in the corresponding position of
<HPT>LCNMCHAR</HPT>.</DD>
<DT>NAMECASE</DT>
<DD>specifies whether upper-case substitution is to be performed
for entity references and entity names ("ENTITY")
and/or
for all other names, name tokens, number tokens,
and delimiter strings ("GENERAL").

<DL TERMHI="2" TSIZE="5">
<DT>YES</DT>
<DD>means an
<HPC>LC Letter</HPC> will be replaced
by the corresponding
<HPC>UC Letter</HPC>,
and a character in
<HPT>LCNMSTRT</HPT> or
<HPT>LCNMCHAR</HPT>
will be replaced by its associated upper-case form.</DD>
<DT>NO</DT>
<DD>means no upper-case substitution will take place.</DD></DL></DD></DL></P>
<P>The upper-case form of a name character can be the same as the lower-case.</P>
<P>A
<HPV>character</HPV> assigned to
<HPT>LCNMCHAR</HPT>,
<HPT>UCNMCHAR</HPT>,

<HPT>LCNMSTRT</HPT>, or
<HPT>UCNMSTRT</HPT> cannot be an

<HPC>LC Letter</HPC>,
<HPC>UC Letter</HPC>,
<HPC>Digit</HPC>,

<HPT>RE</HPT>,
<HPT>RS</HPT>,
<HPT>SPACE</HPT>, or
<HPT>SEPCHAR</HPT>.</P>
<P>A
<HPV>character</HPV> assigned to
<HPT>LCNMCHAR</HPT> or
<HPT>UCNMCHAR</HPT>
cannot be assigned to
<HPT>LCNMSTRT</HPT> or
<HPT>UCNMSTRT</HPT>.</P>
<P>
<HPT>UCNMCHAR</HPT> must have the same number of characters
as
<HPT>LCNMCHAR</HPT>;

<HPT>UCNMSTRT</HPT> must have the same number of characters
as
<HPT>LCNMSTRT</HPT>.</P>
<H3>Delimiter Set</H3>
<PROD>[190] delimiter set =
"DELIM" ,

<HPV>ps</HPV>+,
<HPV>general delimiters</HPV>,

<HPV>ps</HPV>+,
<HPV>short reference delimiters</HPV></PROD>
<LOSTDATA></LOSTDATA>
<P>A delimiter or delimiter-in-context must differ
from every other delimiter and delimiter-in-context
that can be recognized in the same mode.
<REV REFID="AMEND1">
<NT>Different delimiter roles with the same character string can occur in CXT mode,
as long as the resulting delimiters-in-context are unique.</NT></REV></P>
<P>The use of a
<HPV>name start character</HPV> or
<HPC>Digit</HPC>
in a delimiter string is deprecated.</P>
<H4>General Delimiters</H4>
<PROD>[191] general delimiters =
"GENERAL" ,

<HPV>ps</HPV>+, "SGMLREF",
(
<HPV>ps</HPV>+,
<HPV>name</HPV>,
<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>The specified
<HPV>name</HPV> is a name given to a general delimiter role in figure 3.
The interpreted parameter literal is assigned to the role.</P>
<P>General delimiters roles not assigned by this parameter are assigned
as in the reference delimiter set.</P>
<NT>The "SGMLREF" keyword which is required
(and therefore redundant)
is a reminder of this rule for human readers of the SGML declaration.</NT>
<P>A general delimiter string cannot consist solely of function characters.
A general delimiter string that contains such characters
in combination with others is permitted, but is deprecated.</P>
<H4>Short Reference Delimiters</H4>
<PROD>[192] short reference delimiters =
"SHORTREF" ,

<HPV>ps</HPV>+, ("SGMLREF" | "NONE"),
(
<HPV>ps</HPV>+,
<HPV>parameter literal</HPV>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL TERMHI="2" TSIZE="11">
<DT>SGMLREF</DT>
<DD>means that the short references assigned by the reference delimiter set
are included in this delimiter set.</DD>
<DT>NONE</DT>
<DD>means that no short reference delimiters are assigned
except for those assigned by this parameter.</DD></DL></P>
<P>The interpreted parameter literal is assigned as
a short reference delimiter string.</P>
<P>A parameter literal can have a single B sequence,
<REV REFID="AMEND1">which cannot immediately be preceded or followed</REV>
by a blank sequence
or by a reference to a character that can occur in a blank sequence.</P>
<P>A short reference string longer than a single character is deprecated
unless the string is a common keyboarding convention or coding sequence.</P>
<P>A short reference string is deprecated if:

<OL>
<LI>it contains all, or the start, of a delimiter or delimiter-in-context
that is recognized in CON mode;
and</LI>
<LI>it is likely to create the impression
that the delimiter was erroneously ignored.</LI></OL></P>
<NT>In applying this requirement,
remember that a short reference is recognized as a delimiter
even when it is not mapped to an entity.
Therefore, a general delimiter within it will never be recognized as such.</NT>
<H3>Reserved Name Use</H3>
<PROD>[193] reserved name use =
"NAMES" ,

<HPV>ps</HPV>+, "SGMLREF",
(
<HPV>ps</HPV>+,
<HPV>name</HPV>,
<HPV>ps</HPV>+,
<HPV>name</HPV>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>The first of each pair of names is a reference reserved name,
and the second is a name that is to replace it
in the declared concrete syntax.</P>
<NT>Reserved names that occur only in the
<HPV>SGML declaration</HPV>,
including delimiter role, quantity, and capacity names,
cannot be replaced,
as the
<HPV>SGML declaration</HPV> is always in the reference concrete syntax.</NT>
<P>The reference reserved name is used for any reserved name
for which no replacement is assigned by this parameter.</P>
<NT>The "SGMLREF" keyword which is required
(and therefore redundant),
is a reminder of this rule for human readers of the SGML declaration.</NT>
<P>The replacement for a reference reserved name
cannot be another reference reserved name,
or a replacement for one.</P>
<H3>Quantity Set</H3>
<PROD>[194] quantity set =
"QUANTITY" ,

<HPV>ps</HPV>+, "SGMLREF",
(
<HPV>ps</HPV>+,
<HPV>name</HPV>,
<HPV>ps</HPV>+,
<HPV>number</HPV>)*</PROD>
<LOSTDATA></LOSTDATA>
<P>The specified name is a name given to a quantity in figure 6,
which also shows the value assignments
that constitute the reference quantity set.
The designated quantity is assigned
the value indicated by the specified
<HPV>number</HPV>.</P>
<P>The reference quantity set value is used for any quantity
for which no replacement is assigned by this parameter.</P>
<NT>The "SGMLREF" keyword which is required
(and therefore redundant),
is a reminder of this rule for human readers of the SGML declaration.</NT>
<TABLE TYPE="TBL3B">
<TTITLE>Reference Quantity Set
</TTITLE>
<TBODY>
<ROW><C><P>Name</P></C><C><P>Value</P></C><C><P>Description of Quantity</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>ATTCNT</P></C><C><P>40</P></C><C><P>Number of attribute names and name tokens in an <STRONG>attribute definition list</STRONG>.</P></C>
</REV>
</ROW>
<ROW><C><P>ATTSPLEN</P></C><C><P>960</P></C><C><P>Normalized length of a start-tag's <STRONG>attribute specifications</STRONG>.</P></C></ROW>
<ROW><C><P>BSEQLEN</P></C><C><P>960</P></C><C><P>Length of a blank sequence in a short reference string.</P></C></ROW>
<ROW><C><P>DTAGLEN</P></C><C><P>16</P></C><C><P>Length of a data tag.</P></C></ROW>
<ROW><C><P>DTEMPLEN</P></C><C><P>16</P></C><C><P>Length of a data tag template or pattern template (undelimited).</P></C></ROW>
<ROW><C><P>ENTLVL</P></C><C><P>16</P></C><C><P>Nesting level of entities (other than primary).</P></C></ROW>
<ROW><C><P>GRPCNT</P></C><C><P>32</P></C><C><P>Number of tokens in a group.</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>GRPGTCNT</P></C><C><P>96</P></C><C><P>Grand total of content tokens at all levels of a content model
(a data tag group is three tokens).
</P></C>
</REV>
</ROW>
<ROW><C><P>GRPLVL</P></C><C><P>16</P></C><C><P>Nesting level of model groups (including first level).</P></C></ROW>
<ROW>
<REV REFID="AMEND1">
<C><P>LITLEN</P></C><C><P>240</P></C>
<C><P>
Length of a <STRONG>parameter literal</STRONG> or <STRONG>attribute value literal</STRONG>
(interpreted and undelimited).
</P></C>
</REV>
</ROW>
<ROW><C><P>NAMELEN</P></C><C><P>8</P></C><C><P>Length of a <STRONG>name</STRONG>, <STRONG>name token</STRONG>, <STRONG>number</STRONG>, etc.</P></C></ROW>
<ROW><C><P>NORMSEP</P></C><C><P>2</P></C><C><P>Used in lieu of counting separators in calculating normalized lengths.</P></C></ROW>
<ROW><C><P>PILEN</P></C><C><P>240</P></C><C><P>Length of a <STRONG>processing instruction</STRONG> (undelimited).</P></C></ROW>
<ROW><C><P>TAGLEN</P></C><C><P>960</P></C><C><P>Length of a <STRONG>start-tag</STRONG> (undelimited).</P></C></ROW>
<ROW><C><P>TAGVL</P></C><C><P>24</P></C><C><P>Nesting level of open elements.</P></C></ROW>
</TBODY>
</TABLE>

<H2>Feature Use</H2>
<PROD>[195] feature use =
"FEATURES" ,

<HPV>ps</HPV>+,
<HPV>markup minimization features</HPV>,

<HPV>ps</HPV>+,
<HPV>link type features</HPV>,

<HPV>ps</HPV>+,
<HPV>other features</HPV></PROD>
<LOSTDATA></LOSTDATA>
<H3>Markup Minimization Features</H3>
<PROD>[196] markup minimization features =
"MINIMIZE" ,

<HPV>ps</HPV>+, "DATATAG",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "OMITTAG",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "RANK",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "SHORTTAG",
<HPV>ps</HPV>+, ("NO" | "YES")</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="13">
<DT>NO</DT>
<DD>means the feature is not used.</DD>
<DT>YES</DT>
<DD>means the feature is used.</DD>
<DT>DATATAG</DT>
<DD>means data characters may serve simultaneously as tags.</DD>
<DT>OMITTAG</DT>
<DD>means some tags may be omitted altogether.</DD>
<DT>RANK</DT>
<DD>means element ranks may be omitted from tags.</DD>
<DT>SHORTTAG</DT>
<DD>means short tags with omitted delimiters, attribute specifications,
or generic identifiers may be used.</DD></DL></P>
<NT>The use of short references is not specified in this parameter,
because it is specified by the "SHORTREF" parameter.</NT>
<H3>Link Type Features</H3>
<PROD>[197] link type features =
"LINK" ,

<HPV>ps</HPV>+, "SIMPLE",

<REV REFID="AMEND1">
<HPV>ps</HPV>+, ("NO" | ("YES",
<HPV>ps</HPV>+
<HPV>number</HPV>)),</REV>

<HPV>ps</HPV>+, "IMPLICIT",

<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "EXPLICIT",

<HPV>ps</HPV>+, ("NO" | ("YES",
<HPV>ps</HPV>+
<HPV>number</HPV>))</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>NO</DT>
<DD>means the feature is not used.</DD>
<DT>YES</DT>
<DD>means the feature is used.</DD>
<DT>EXPLICIT</DT>
<DD>means explicit link process definitions may be used
and the longest chain of link processes
has the specified number of links (1 or more).</DD>
<DT>IMPLICIT</DT>
<DD>means implicit link process definitions may be used.</DD>
<DT>SIMPLE</DT>
<DD>means simple link process definitions may be used
<REV REFID="AMEND1">and the specified number can be active simultaneously (1 or more).</REV></DD></DL></P>
<H3>Other Features</H3>
<PROD>[198] other features =
"OTHER" ,

<HPV>ps</HPV>+, "CONCUR",

<HPV>ps</HPV>+, ("NO" | ("YES",
<HPV>ps</HPV>+
<HPV>number</HPV>)),

<HPV>ps</HPV>+, "SUBDOC",

<HPV>ps</HPV>+, ("NO" | ("YES",
<HPV>ps</HPV>+
<HPV>number</HPV>)),

<HPV>ps</HPV>+, "FORMAL",

<HPV>ps</HPV>+, ("NO" | "YES")</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>NO</DT>
<DD>means the feature is not used.</DD>
<DT>YES</DT>
<DD>means the feature is used.</DD>
<DT>CONCUR</DT>
<DD>means instances of the specified number of document types (1 or more)
may occur concurrently with an instance of the base document type.</DD>
<DT>SUBDOC</DT>
<DD>means the specified number of SGML subdocument entities (1 or more)
may be open at one time.</DD>
<DT>FORMAL</DT>
<DD>means that public identifiers are interpreted as formal public identifiers.</DD></DL></P>
<H2>Application-specific information</H2>
<PROD>[199] application-specific information =
"APPINFO",
<HPV>ps</HPV>+,
("NONE" |
<HPV>minimum literal</HPV>)</PROD>
<LOSTDATA></LOSTDATA>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>NONE</DT>
<DD>means that no application-specific information has been specified.</DD></DL></P>
<P>The
<HPV>minimum literal</HPV> specifies application-specific information
that is applicable to the document.</P>
<FIG FRAME="box" PLACE="TOP" WIDTH="page">
<FIGBODY>
<XMP>             SYNTAX

   SHUNCHAR  CONTROLS 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
                18 19 20 21 22 23 24 25 26 27 28 29 30 31 127 255
   BASESET   "ISO 646-1983//CHARSET
              International Reference Version (IRV)//ESC 2/5 4/0"
   DESCSET   0 128 0
   FUNCTION  RE                13
             RS                10
             SPACE             32
             TAB      SEPCHAR   9
   NAMING    LCNMSTRT ""
             UCNMSTRT ""
             LCNMCHAR "-."     -- Lower-case hyphen, period are --
             UCNMCHAR "-."     -- same as upper-case (45 46).   --
             NAMECASE GENERAL  YES
                      ENTITY   NO
   DELIM     GENERAL  SGMLREF
             SHORTREF SGMLREF
   NAMES     SGMLREF
   QUANTITY  SGMLREF</XMP></FIGBODY>
<FIGCAP>Reference Concrete Syntax</FIGCAP></FIG>
<H1>Reference and Core Concrete Syntaxes</H1>
<LOSTDATA></LOSTDATA>
<P>The reference concrete syntax is defined by the
SGML declaration
<HPV>concrete syntax</HPV> parameter shown in figure 7.
Its
<HPV>public identifier</HPV> is:

<XMP>
<Q>ISO 8879-1986//SYNTAX Reference//EN</Q></XMP></P>
<P>The core concrete syntax is the same as the reference concrete syntax,
except that "NONE" is specified for the
"SHORTREF" parameter.
Its
<HPV>public identifier</HPV> is:

<XMP>
<Q>ISO 8879-1986//SYNTAX Core//EN</Q></XMP></P>
<NT>The
<HPV>syntax-reference character set</HPV> of the reference concrete syntax
is ISO 646 IRV.
That set consists of characters numbered 0 through 127,
which correspond to the like-numbered characters in ISO 4873 and ISO 6937.
The set was chosen because it is the simplest standard character set
that contains all of the significant SGML characters
used in the reference concrete syntax.
This choice does not restrict the document character sets that can be used,
nor their size.</NT>
<H1>Conformance</H1>
<LOSTDATA></LOSTDATA>
<H2>Conforming SGML Document</H2>
<LOSTDATA></LOSTDATA>
<P>If an SGML document complies with all provisions of this International Standard
it is a conforming SGML document.</P>
<FIG FRAME="box" PLACE="TOP" WIDTH="page">
<FIGBODY>
<XMP>
                    <!SGML "ISO 8879-1986"
            -- This document is a basic SGML document. --

                             CHARSET
            -- 8-bit document character set whose first 128 characters
               are the same as the syntax-reference character set. --
   BASESET  "ISO 646-1983//CHARSET
             International Reference Version (IRV)//ESC 2/5 4/0"
   DESCSET    0   9  UNUSED
              9   2   9
             11   2  UNUSED
             13   1  13
             14  18  UNUSED
             32  95  32
            127   1  UNUSED
   BASESET  "ISO Registration Number 109//CHARSET
<REV REFID="AMEND1">             ECMA-94 Right Part of Latin Alphabet Nr. 3//ESC 2/9 4/3"</REV>
   DESCSET  128  32  UNUSED
            160   5  32
            165   1  "SGML User's Group logo"
            166  88  38          -- Includes 5 unused for NONSGML --
            254   1  127         -- Move 127 to unused position as --
            255   1  UNUSED      -- 255 is shunned character number --

   CAPACITY PUBLIC "ISO 8879-1986//CAPACITY Reference//EN"
   SCOPE    DOCUMENT
   SYNTAX   PUBLIC "ISO 8879-1986//SYNTAX Reference//EN"

                            FEATURES
   MINIMIZE DATATAG NO  OMITTAG  YES  RANK     NO  SHORTTAG YES
   LINK     SIMPLE  NO  IMPLICIT NO   EXPLICIT NO
   OTHER    CONCUR  NO  SUBDOC   NO   FORMAL   NO

                          APPINFO NONE></XMP></FIGBODY>
<FIGCAP>Typical SGML Declaration for Basic SGML Document</FIGCAP></FIG>
<H3>Basic SGML Document</H3>
<LOSTDATA></LOSTDATA>
<P>If a conforming SGML document uses the reference concrete syntax throughout,
the reference capacity set, and only the SHORTTAG and OMITTAG features,
it is a basic SGML document.</P>
<NT>A typical SGML declaration for a basic SGML document is shown in figure 8.
Only the
<HPV>document character set</HPV> parameter can differ
from one basic SGML document to another.</NT>
<H3>Minimal SGML Document</H3>
<LOSTDATA></LOSTDATA>
<P>If a conforming SGML document uses the core concrete syntax,
the reference capacity set, and no features,
it is a minimal SGML document.</P>
<H3>Variant Conforming SGML Document</H3>
<LOSTDATA></LOSTDATA>
<P>If a conforming SGML document uses a variant concrete syntax,
it is a variant conforming SGML document.</P>
<H2>Conforming SGML Application</H2>
<LOSTDATA></LOSTDATA>
<P>If an SGML application meets the requirements of this sub-clause
it is a conforming SGML application.</P>
<H3>Application Conventions</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML application's conventions can affect only areas
that are left open to specification by applications.</P>
<NT>Some examples are:
naming conventions for elements and entities,
or a content convention
<REV REFID="AMEND1">that data characters not in the syntax-reference character set</REV>
always be entered by references rather than directly.</NT>
<H3>Conformance of Documents</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML application shall require
its documents to be conforming SGML documents,
and shall not prohibit any markup
that this International Standard would allow in such documents.</P>
<NT>For example, an application markup convention could recommend
that only certain minimization functions be used,
but could not prohibit the use of others functions
if they are allowed by the formal specification.</NT>
<H3>Conformance of Documentation</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML application's documentation shall meet
the requirements of this International Standard (see 15.5).</P>
<H2>Conforming SGML System</H2>
<LOSTDATA></LOSTDATA>
<P>If an SGML system meets the requirements of this sub-clause
it is a conforming SGML system.</P>
<NT>An effect of this sub-clause is to require
that a conforming SGML system be able to process a minimal SGML document.</NT>
<H3>Conformance of Documentation</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system's documentation shall meet
the requirements of this International Standard (see 15.5).</P>
<H3>Conformance to System Declaration</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system shall be capable of processing
any conforming SGML document that is not inconsistent
with the system's
<HPV>system declaration</HPV> (see 15.6).</P>
<NT>As this International Standard does not define
data content notations or system data,
a system's inability to process such text does not affect whether
it is a conforming SGML system.</NT>
<H3>Support for Reference Concrete Syntax</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system shall be able to parse documents
in the reference concrete syntax
in addition to any variant concrete syntax that it may support.</P>
<NT>This requirement can be satisfied by converting from the reference
to the system concrete syntax when a document is received.</NT>
<P>A conforming SGML system
that can create or revise SGML documents
shall be able to do so for SGML documents that
use the reference concrete syntax.</P>
<NT>This requirement can be satisfied by converting from the system
to the reference concrete syntax when a document is to be exported.</NT>
<P>If a conforming SGML system allows a user to edit SGML markup directly,
it must also allow the reference concrete syntax to be edited directly.</P>
<P>If an SGML system does not support short references in any syntax,
the core concrete syntax can be used instead of the reference concrete syntax.

<NOTEL>
<LI>A system can meet the requirement to support the reference concrete syntax
by using separate programs or modules.</LI>
<LI>This requirement should not be interpreted to require
that interchange be restricted to the reference concrete syntax;
document can be interchanged in variant concrete syntaxes as well.</LI></NOTEL></P>
<H3>Support for Reference Capacity Set</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system shall be able to parse documents
whose capacities are not greater than those of the reference capacity set.
If SGML documents can be created with the system,
the system shall be able to create documents
whose capacities are not greater than those of the reference capacity set.</P>
<H3>Consistency of Parsing</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system shall parse the same document identically
for all applications and processes that operate on it.

<NOTEL>
<LI>An application program,
using normal interfaces to the SGML parser,
should not be able to affect the state of the parse,
such as by generating text and causing it to be parsed
as though it were part of the document.
Documentation for application developers
should made them aware of this requirement.</LI>
<LI>This requirement enables a system to be tested for conformance
without having to test every application.</LI></NOTEL></P>
<H3>Application Conventions</H3>
<LOSTDATA></LOSTDATA>
<P>A conforming SGML system shall not enforce application conventions
as though they were requirements of this International Standard.</P>
<NT>Warnings of the violation of application conventions can be given,
but they must be distinguished from reports of markup errors.</NT>
<H2>Validating SGML Parser</H2>
<LOSTDATA></LOSTDATA>
<P>If an SGML parser in a conforming SGML system
meets the requirements of this sub-clause,
it is a validating SGML parser.</P>
<NT>A conforming SGML system need not have a validating SGML parser.
Implementors can therefore decide
whether to incur the overhead of validation in a given system.
An user whose text editing system allowed
the validation and correction of SGML documents, for example,
would not require the validation process to be repeated
when the documents are processed by a formatting system.</NT>
<H3>Error recognition</H3>
<LOSTDATA></LOSTDATA>
<P>A validating SGML parser
shall find and report a reportable markup error if one exists,
and shall not report an error when none exists.</P>
<P>
<REV REFID="AMEND1">A validating SGML parser can optionaly report other errors (see 4.267).</REV></P>
<NT>This International Standard does not specify
how a markup error should be handled,
beyond the requirement for reporting it.
In particular,
it does not state whether the erroneous text should be treated as data,
and/or whether an attempt should be made to continue processing
after an error is found.</NT>
<REV REFID="AMEND1">
<P>A validating SGML parser may warn of conditions
that are potentially, but not necessarily, errors.</P>
<NT>For example,
a generic identifier that is an optional token in a
<HPV>model group</HPV>
but is not declared,
could be an error if this element occured in the document instance.</NT></REV>
<H3>Identification of SGML Messages</H3>
<LOSTDATA></LOSTDATA>
<P>Reports of SGML markup errors, including optional reports,
shall be identified as SGML messages
in such a manner to distinguish them clearly from all other messages,
<REV REFID="AMEND1">including warning of potential SGML errors.</REV></P>
<H3>Content of SGML Messages</H3>
<LOSTDATA></LOSTDATA>
<P>A report of an SGML markup error, including an optional report,
shall state the nature and location of the error
in sufficient detail to permit its correction.</P>
<NT>This requirement is worded to allow implementors maximum flexibility
to meet their user and system requirements.
More precise suggestions are made in clause F.4.</NT>
<H2>Documentation Requirements</H2>
<LOSTDATA></LOSTDATA>
<P>The objectives of this International Standard will be met most effectively
if users, at all levels, are aware that
SGML documents conform to an International Standard
that is independent of any application or parser.
The documentation of a conforming SGML system or application
shall further such awareness.</P>
<NT>These requirements are intended
to help users apply knowledge gained from one SGML system
to the use of other systems,
not to inhibit a casual and friendly writing style.</NT>
<H3>Standard Identification</H3>
<LOSTDATA></LOSTDATA>
<P>Standard identification should be
in the national language of the documentation.</P>
<P>Standard identification text should be displayed prominently:

<OL SPREAD="COMPACT">
<LI>in a prominent location in the front matter of all publications
(normally the title page and cover page);</LI>
<LI>on all identifying display screens or programs;
and</LI>
<LI>in all promotional and training material.</LI></OL></P>
<P>For applications, the identification text is:

<XMP>An SGML Application Conforming to
International Standard ISO 8879 --
Standard Generalized Markup Language</XMP></P>
<P>For systems, the identification text is:

<XMP>An SGML System Conforming to
International Standard ISO 8879 --
Standard Generalized Markup Language</XMP></P>
<P>The documentation for a conforming SGML system
shall include a system declaration (see 15.6).</P>
<H3>Identification of SGML Constructs</H3>
<LOSTDATA></LOSTDATA>
<P>The documentation shall distinguish SGML constructs
from application conventions and system functions,
and shall identify the SGML constructs as being part of the
Standard Generalized Markup Language.</P>
<NT>The objective of this requirement is for the user to be aware
of which constructs are common to all SGML systems,
and which are unique to this one.
This will reduce the experienced user's learning time
for a new system or application.</NT>
<P>This International Standard shall be cited
as a reference for supported SGML constructs
that are not specifically documented for the system or application.
For example, if, for simplicity's sake,
only a subset of functions is presented
(such as by omitting some of the options of the entity declaration),
it shall be stated clearly that other options exist
and can be found in this International Standard.</P>
<H3>Terminology</H3>
<LOSTDATA></LOSTDATA>
<P>All SGML constructs shall be introduced
using the terminology of this International Standard,
translated to the national language used by the publication of program.</P>
<P>Such standard terminology should be used throughout the documentation.
If, notwithstanding, a non-standard equivalent is used for a standard term,
it must be introduced in context
and it shall not conflict with any standard SGML terms,
including terms for unsupported or undocumented constructs.</P>
<H3>Variant Concrete Syntax</H3>
<LOSTDATA></LOSTDATA>
<P>If a variant concrete syntax is used, that fact shall be made clear to the user.
The rules of that syntax shall not be attributed to SGML.</P>
<H2>System Declaration</H2>
<PROD>[200] system declaration =

<HPD>mdo</HPD>, "SYSTEM",

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPV>minimum literal</HPV>,</REV>

<HPV>ps</HPV>+,
<HPV>document character set</HPV>,

<HPV>ps</HPV>+,
<HPV>capacity set</HPV>,

<HPV>ps</HPV>+,
<HPV>feature use</HPV>,

<HPV>ps</HPV>+,
<HPV>concrete syntax scope</HPV>,

<HPV>ps</HPV>+,
<HPV>concrete syntaxes supported</HPV>,

<HPV>ps</HPV>+,
<HPV>validation services</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+,
<HPV>SDIF support</HPV>,</REV>

<HPV>ps</HPV>*,
<HPD>mdc</HPD></PROD>
<LOSTDATA></LOSTDATA>
<P>A
<HPV>system declaration</HPV> must meet the same syntax requirements
as an
<HPV>SGML declaration</HPV>
with respect to the concrete syntax used, data characters allowed, etc.
<REV REFID="AMEND1">
<P>The
<HPV>minimum data</HPV> of the
<HPV>minimum literal</HPV>
must be
<Q>ISO 8879:1986</Q>.</P>
<P>The
<HPV>document character set</HPV> parameter is specified
as on the
<HPV>SGML declaration</HPV>,
except that the system character set is being described,
rather than that of a document.
The system character set must include a coded representation,
as a single bit combination,
for each significant SGML character in every concrete syntax
described by the
<HPV>concrete syntaxes supported</HPV> parameter.</P></REV></P>
<P>The
<HPV>capacity set</HPV> parameter is specified
as on the
<HPV>SGML declaration</HPV>,
except that the capacity of the system is being described,
rather than the capacity requirements of a document.</P>
<P>The
<HPV>feature use</HPV> parameter is specified
as on the
<HPV>SGML declaration</HPV>,
except that the ability of the system to support a feature is being described,
rather than the characteristics of a document that uses the feature.</P>
<P>The
<HPV>concrete syntax scope</HPV> parameter is specified
as on the
<HPV>SGML declaration</HPV>,
except that the ability of the system to support two syntaxes at once
is being described,
rather than whether a document uses two syntaxes.</P>
<NT>The
<HPV>system declaration</HPV> should include comments to indicate
which data content notations and types of
<HPV>system data</HPV>
the system can support.</NT>
<H3>Concrete Syntaxes Supported</H3>
<LOSTDATA></LOSTDATA>
<P>This parameter specifies the concrete syntaxes that the
system SGML parser can parse and any allowed variations.
<PROD>[201] concrete syntaxes supported =
(
<HPV>ps</HPV>+,
<HPV>concrete syntax</HPV>,

<REV REFID="AMEND1">(
<HPV>ps</HPV>+,
<HPV>concrete syntax changes</HPV>)?)+</REV></PROD></P>
<P>A
<HPV>concrete syntax</HPV> parameter is specified,
as on the
<HPV>SGML declaration</HPV>,
for each concrete syntax that the system can parse.
One of the specified concrete syntaxes must be
the reference concrete syntax,
if short references are supported for any concrete syntax,
or the core concrete syntax if they are not.</P>
<H4>Concrete Syntax Changes</H4>
<LOSTDATA></LOSTDATA>
<P>This parameter describes concrete syntaxes that the system can parse,
that are minor modifications of the specified
<HPV>concrete syntax</HPV>.
The keywords define the nature and extent of the permitted changes.
<PROD>[202] concrete syntax changes =
"CHANGES",

<HPV>ps</HPV>+,
("SWITCHES" |
("DELIMLEN",
<HPV>ps</HPV>+,
<HPV>number</HPV>,

<HPV>ps</HPV>+, "SEQUENCE",
<HPV>ps</HPV>+, ("YES" | "NO"),

<HPV>ps</HPV>+, "SRCNT",
<HPV>ps</HPV>+,
<HPV>number</HPV>,

<REV REFID="AMEND1">
<HPV>ps</HPV>+, "SRLEN",
<HPV>ps</HPV>+,
<HPV>number</HPV>))</REV></PROD></P>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>SWITCHES</DT>
<DD>
<REV REFID="AMEND1">means that changes specified by use of the "SWITCHES" parameter
of the
<HPV>SGML declaration</HPV> are permitted.</REV></DD>
<DT>DELIMLEN</DT>
<DD>means that new strings that do not exceed the specified number of characters
(1 or more) can be assigned to
<REV REFID="AMEND1">general delimiter roles.</REV></DD>
<DT>SEQUENCE</DT>
<DD>indicates whether a blank sequence can be used in short reference delimiters.
If so, it is considered to have a length of 1 character.</DD>
<DT>SRCNT</DT>
<DD>
<REV REFID="AMEND1">means that a different set of short reference strings can be assigned,
as long as it does not exceed the specified number (0 or more).</REV>
<REV REFID="AMEND1">
<DT>SRLEN</DT>
<DD>means that any new short reference strings must not exceed
the specified number of characters (1 or more).</DD></REV></DD></DL></P>
<H3>Validation Services</H3>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>validation services</HPV> parameter specifies
whether a system has a validating SGML parser,
and which, if any, optional validation services it provides.
<PROD>[203] validation services =
"VALIDATE" ,

<HPV>ps</HPV>+, "GENERAL",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "MODEL",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "EXCLUDE",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "CAPACITY",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "NONSGML",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "SGML",
<HPV>ps</HPV>+, ("NO" | "YES"),

<HPV>ps</HPV>+, "FORMAL",
<HPV>ps</HPV>+, ("NO" | "YES")</PROD></P>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>NO</DT>
<DD>means the service is not provided.</DD>
<DT>YES</DT>
<DD>means the service is provided.</DD>
<DT>GENERAL</DT>
<DD>means a reportable markup error will be found and reported.</DD>
<DT>MODEL</DT>
<DD>means an ambiguous content model will be reported.</DD>
<DT>EXCLUDE</DT>
<DD>means an exclusion that could change a
<REV REFID="AMEND1">token's required or optional status</REV>
in a model will be reported.</DD>
<DT>CAPACITY</DT>
<DD>means that exceeding a capacity limit will be reported.</DD>
<DT>NONSGML</DT>
<DD>means the occurrence of at least one non-SGML character,
but not necessary all, will be reported.</DD>
<DT>SGML</DT>
<DD>means an error in the SGML declaration will be reported.</DD>
<DT>FORMAL</DT>
<DD>means a formal public identifier error will be reported.</DD></DL>
<REV REFID="AMEND1">
<H3>SDIF support</H3>
<LOSTDATA></LOSTDATA>
<P>The
<HPV>SDIF support</HPV> parameter specifies
whether the system can interchange documents by means of the
SGML Document Interchange Format (SDIF) defined in ISO 9069.
<PROD>[204] SDIF support =
"SDIF" ,

<HPV>ps</HPV>+, "PACK",

<HPV>ps</HPV>+, ("NO" | ("YES", (
<HPV>ps</HPV>+, "ASN1")?)),

<HPV>ps</HPV>+, "UNPACK",

<HPV>ps</HPV>+, ("NO" | ("YES", (
<HPV>ps</HPV>+, "ASN1")?))</PROD></P>
<P>where:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DT>PACK</DT>
<DD>is the function of creating an SDIF data stream from one or more entities.</DD>
<DT>UNPACK</DT>
<DD>is the function of decomposing an SDIF data stream
into its constituent entities.</DD>
<DT>NO</DT>
<DD>means that the specified SDIF function is not supported.</DD>
<DT>YES</DT>
<DD>means the specified SDIF function is supported.</DD>
<DT>ASN1</DT>
<DD>means the specified SDIF function is supported
for SDIF data stream encoded according to the ASN.1 basic encoding rules
specified in ISO 8825.</DD></DL></P></H3></REV></P></BODY>
<APPENDIX>
<H1>Conformance Classification and Certification</H1>
<LOSTDATA>(This annex does not form an integral part of this International Standard.)</LOSTDATA>
<P>This International Standard offers
a variety of conformance options to SGML systems.
It is expected that agencies that certify conformance
will want to define a meaningful subset of these options for testing.
They will also need a simple way to classify certified systems
that will precisely identify the features and syntax and variations
that the systems support.</P>
<P>This annex describes a classification scheme
that satisfies both these objectives,
and discusses some of the implications for certification agencies.</P>
<H2>Classification Code</H2>
<LOSTDATA></LOSTDATA>
<P>The classification scheme is summarized in
<FIGREF REFID="FIG15">
The scheme assigns SGML systems a conformance classification code
that consists of three subordinate codes:
feature, syntax and validation.
For this reason, the conformance classification code
can be called an
<Q>FSV</Q>.</P>
<P>For example, the FSV
<Q>0768RS064</Q> is composed of
feature code
<Q>0768</Q>,
syntax code
<Q>RS</Q>, and
validation code
<Q>064</Q>.
It is the classification code for a system that can
validate basic SGML documents
with no features or validation options.</P>
<P>According to the figure,
the classification name is
<Q>basic, validating</Q>.
If the validation code were
<Q>000</Q>,
the validation suffix would change,
and the classification name would be
<Q>basic, non-validating</Q>.</P>
<P>As the features, concrete syntax, and validation options
of a conforming system can vary independantly of one another,
it is not possible to define a single conformance classification hierarchy.
Instead, there are two hierarchies,
one based on the feature code and one on the validation code,
as shown in the figure.</P>
<TABLE TYPE=TABLE5>
<TTITLE>FSV Conformance Classification</TTITLE>
<TBODY>
<ROW>
<C><P>CONFORMANCE CLASS NAME</P></C>
<C><P>FEATURE CODE: F</P></C>
<C><P>SYNTAX CODE: S</P></C>
<C><P>VALID CODE: V</P></C>
<C><P>VALIDATION SUFFIX</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal</P></C>
<C><P>0000</P></C>
<C><P>CS</P></C>
<C><P>000</P></C>
<C><P>non-validating</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>CS</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Basic</P></C>
<C><P>0768</P></C>
<C><P>RS</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>RS</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Full</P></C>
<C><P>1023</P></C>
<C><P>RS</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal</P></C>
<C><P>0000</P></C>
<C><P>MC</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>MC</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode basic</P></C>
<C><P>0768</P></C>
<C><P>MB</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Multicode basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>MB</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Multicode full</P></C>
<C><P>1023</P></C>
<C><P>MB</P></C>
<C><P>000</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal</P></C>
<C><P>0000</P></C>
<C><P>CS</P></C>
<C><P>064</P></C>
<C><P>validating</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>CS</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Basic</P></C>
<C><P>0768</P></C>
<C><P>RS</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>RS</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Full</P></C>
<C><P>1023</P></C>
<C><P>RS</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal</P></C>
<C><P>0000</P></C>
<C><P>MC</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>MC</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode basic</P></C>
<C><P>0768</P></C>
<C><P>MB</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Multicode basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>MB</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Multicode full</P></C>
<C><P>1023</P></C>
<C><P>MB</P></C>
<C><P>064</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal</P></C>
<C><P>0000</P></C>
<C><P>CS</P></C>
<C><P>065-127</P></C>
<C><P>validating with options</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>CS</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Basic</P></C>
<C><P>0768</P></C>
<C><P>RS</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>RS</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Full</P></C>
<C><P>1023</P></C>
<C><P>RS</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal</P></C>
<C><P>0000</P></C>
<C><P>MC</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode minimal with options</P></C>
<C><P>0001-0767</P></C>
<C><P>MC</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<C><P>Multicode basic</P></C>
<C><P>0768</P></C>
<C><P>MB</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</ROW>
<ROW TYPE=NRULE>
<REV REFID="AMEND1">
<C><P>Multicode basic with options</P></C>
<C><P>0769-1022</P></C>
<C><P>MB</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</REV>
</ROW>
<ROW TYPE=BOTTOM>
<REV REFID="AMEND1">
<C><P>Multicode full</P></C>
<C><P>1023</P></C>
<C><P>MB</P></C>
<C><P>065-127</P></C>
<C><P>=</P></C>
</REV>
</ROW>
</TBODY>
</TABLE>


<H3>Feature Code</H3>
<LOSTDATA></LOSTDATA>
<P>The feature code is determined by summing the factors
assigned in the following list to each supported feature:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DTHD>Feature</DTHD>
<DDHD>Weight</DDHD>
<DT>FORMAL</DT>
<DD>1</DD>
<DT>CONCUR</DT>
<DD>2</DD>
<DT>EXPLICIT</DT>
<DD>4</DD>
<DT>IMPLICIT</DT>
<DD>8</DD>
<DT>SIMPLE</DT>
<DD>16</DD>
<DT>SUBDOC</DT>
<DD>32</DD>
<DT>RANK</DT>
<DD>64</DD>
<DT>DATATAG</DT>
<DD>128</DD>
<DT>OMITTAG</DT>
<DD>256</DD>
<DT>SHORTTAG</DT>
<DD>512</DD></DL></P>
<P>If necessary, the code is padded with high-order zeros
to make it the same length as the largest possible code.</P>
<P>The feature numbers are weighted (they are power of two)
so that the feature code will uniquely identify
the features that are supported.
For example, a feature code of 0384 means that
DATATAG and OMITTAG features are supported, and no others.</P>
<NT>The method described works when
all features are specified independently
and each is either supported or unsupported;
that is, there are two possible values for each feature,
0 (unsupported) and 1 (supported).
In the general case,
there are N possible values, V,
ranging from V=0 through V=N-1.
For each feature, there is a factor, F,
which is the product of N times the previous feature's factor, G
(G is 1 for the first feature).
The weigth for a given value, W(V), is the product of V times G.
(To summarize: F=N*G and W(V)=V*G,
where the asterisk means multiplication.)</NT>
<H3>Validation Code</H3>
<LOSTDATA></LOSTDATA>
<P>The validation code is determined by summing the factors
assigned in the following list to each supported validation feature:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="11">
<DTHD>Feature</DTHD>
<DDHD>Weight</DDHD>
<DT>CAPACITY</DT>
<DD>1</DD>
<DT>EXCLUDE</DT>
<DD>2</DD>
<DT>SGML</DT>
<DD>4</DD>
<DT>MODEL</DT>
<DD>8</DD>
<DT>FORMAL</DT>
<DD>16</DD>
<DT>NONSGML</DT>
<DD>32</DD>
<DT>GENERAL</DT>
<DD>64</DD></DL></P>
<P>If necessary, the code is padded with high-order zeros
to make it the same length as the largest possible code.</P>
<P>A system that did only general validation
would have a validation code of 064.
As this International Standard requires general validation
as a prerequisite to any of the validation options,
the only possible validation codes would be 000, and 064 through 127.</P>
<NT>If modifying this scheme,
GENERAL must have the highest weight,
and no validation code can be lower than the weight of GENERAL,
unless it is 0.</NT>
<H3>Syntax Code</H3>
<LOSTDATA></LOSTDATA>
<P>The code for the concrete syntax
is one of those in the following list:

<DL SPREAD="COMPACT" TERMHI="2" TSIZE="7">
<DTHD>Code</DTHD>
<DDHD>Concrete Syntax</DDHD>
<DT>CS</DT>
<DD>Core concrete syntax</DD>
<DT>RS</DT>
<DD>Reference concrete syntax</DD>
<DT>MC</DT>
<DD>Multicode core concrete syntax</DD>
<DT>MB</DT>
<DD>Multicode basic concrete syntax</DD></DL></P>
<P>The listed syntaxes are those defined in the document.</P>
<P>The classification scheme assumes that
conformance will be tested for a single concrete syntax
used in both the prolog and the document element.</P>
<H2>Certification Considerations</H2>
<LOSTDATA></LOSTDATA>
<P>It is important to note that a conformance classification scheme
is not a constraint on either certification agencies or implementors.
Conformance is defined in clause 15 of this International Standard,
and is expressed formally in a system declaration,
for which a conformance classification code is
only an informal partial summary.</P>
<P>An implementor can choose to offer
as many features and concrete syntax variations
as it thinks its users will require.
A certification agency can offer testing
for as narrow or wide a group of these as it wishes.
As a result,
a given certification may not include all of the function
that the tested system claims to offer,
but that does not mean
the system failed to conform to this International Standard.
It simply means that,
with respect to certain functions of the system,
the certification agency offers no opinions on whether it conforms.</P>
<P>Certification agencies should feel free
to modify the suggested classification scheme
to meet their requirements,
or to ignore it altogether.
An agency, however,
regardless of the classification scheme it adopts,
must recognize that
it cannot declare a system to be conforming or nonconforming
by any criteria other than those specified in this International Standard.
In particular,
it cannot consider a system to be non-conforming
solely because its mix of functions
does not fit the agency's classification scheme.
The agency must certify (or not, as the testing indicates)
as to those functions that it is willing to test,
and declare that it has no opinion as to the others.</P></APPENDIX></USERDOC>
